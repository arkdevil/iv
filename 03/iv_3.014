█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█  ▀					    ▀	       ███▀▀███
█ STEALTH group	█░ █ █▀▄ █▀▀ ▄▀▀ ▄▀▀ ▀█▀ ▄▀▀ █▀█    ▌ █ ▄▀█ █ ▄▀▀ ▄▀▀  ████▀▄██
█   presents	█░ █ █ █ █▀  █▀  █    █  █▀  █ █    █ █ █ █ █ █  ▀█▀▀  █████ ██
█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█░ ▐ ▐ ▐ ▐   ▐▄▄ ▐▄▄  ▐  ▐▄▄ ▐▄▀     ▀█ ▀▄█ ▐ ▐▄▄ ▐▄▄  ███▄▄███
 ░░░░░░░░░░░░░░░░░                                                     DEC 1994

 INFECTED VOICE. Issue 3. November 1994. (C) STEALTH group, Kiev-148, Box 10.
 === ITEM * === 					     === PAGE ** ===								
 
	Предлагаю вашему вниманию переведенную мной статью из Американского
 вирусного журнала "40hex" (No.6) под названием "Concealment: Keep Your Code
 Hidden From Prying Eyes" by Demogorgon/PHALCON/SKISM.
	 Материал, несомненно заслуживает внимания,  особенно как пища для
 размышлений. В последнее время эта тема очень актуальна  в связи с выпуском
 антивирусов типа "WEB", который, как вы знаете, способен  определить тип 
 находящегося в файле вируса - COM, EXE, Resident ... Тут уже  могут не помочь
 простые технологии Phantom, необходимы новые методы противодействия,
 в особенности символическому исполнению кода. Так что, давайте задумаемся 
 (а не заDoomаемся) и пусть восторжествует жизнь! Плодитесь и размножайтесь!

					 LovinGOD. 

40HEX_6_002     SEGMENT PUBLIC 'code'
                ORG 100H
                ASSUME CS:CODE,DS:CODE,SS:CODE,ES:CODE

;******************************************************************************

Concealment:      Keep Your Code Hidden From Prying Eyes
                                        by Demogorgon/PHALCON/SKISM


     Недавно я экспериментировал с приемами программирования, которыми будет
 интересно поделиться с нашей вирусной братией. Наш главный козырь - скрытие 
 кода от всяких лэмеров, любящих извращать тексты, и антивирусников для того,
 чтобы они пострадали подольше.
     Для этого мы должны приложить большие усилия по сокрытию кода, о чем я 
расскажу в нашей статье.
     В этом файле 2 части. Первая посвящена развитию кода, сопротивляющегося
трассировке, а вторая - борьбе с дизассемблерами.
     Я не буду освещать шифрование, потому как это общеизвестно.

Часть_1: Дебаггер  нам НЕ товарищ.

     Основная идея написания противодебаггерного кода состоит в извращении
кода, запущенного под отладчиком. В реальном режиме - сама простота.
 Единственное, что необходимо, это немного знать о том, как работает отладчик.
 Отладчики, такие, как Debug или TD трассируют программы посредством установки
 обработчиков INT 1 и INT 3. Они вызываются после каждой исполняемой инструк-
 ции. Вирус, желающий избежать отладки, может просто сменить вектора этих пре-
 рываний. Результат будет налицо.
	 В коде это выглядит так: 
eat_debug:
        push    cs
        pop     ds
        mov     dx, offset eat_int
        mov     ax,2501h
        int     21h
        mov     al,03h
        int     21h
        ...                     ; остальной код
eat_int: iret

     Как мы видим, это не занимает ни много места, ни времени.
		 Вы можете экспериментировать, помещая чтонибудь в EAT_INT.
     Еще один общеиспользуемый прием- это отрубание прерывания клавиатуры на 
время исполнения вирусов. Это осадит лэймеров, не смогущих понять, что же про-
изошло.
 Пока это поражает среднестатистический дебаггер реального режима, любой деба-
ггер защищенного режима запросто обойдет эти штучки, как будто бы их и не было
  Игры с прерываниями не помогут вам в режиме виртуального CPU.
Есть один метод, найденный мной, который прекрасно работает против TD386 - 
инструкция HLT.  Произойдет Exception error #13, и программа завершится.
 Те, кто опасается, что это можно просто перешагнуть, прийдется скрыть присут-
ствие данной инструкции или сделать ее необходимой частью кода. Об этом - 2ая
часть статьи.
Еще один трюк - вызов INT 3 внутри вашей программы. Если ктото попытается за-
пустить вашу программу под отладчиком, он будет останавливаться каждый раз при
вызове INT 3. Конечно, сквозь это можно пройти, но будет очень нудно, если 
напихать INT 3 повсюду.

Часть_2: Убей дизассемблер ! 

    Неважно, как хорошо ты надул дебаггер, но твоя программа полностью зависит
от милости программиста, вооруженного хорошим дизассемблером. Если, конечно,
не использовать приемов , которые сконфузят дизассемблер. Мой любимый метод
для наколки - это перекрывающийся код. Он может показаться немного сложным
для большинства из нас, но зная нескольо HEX-значений инструкций процессора,
вы тоже сможете сделать небольшой по размеру перекрывающийся код.
   Перекрывающийся код можно сделать сколь угодно многоуровневым, здесь же мы
поимеем дело с простейшими примерами.

eat_sr: mov     ax,02EBh
        jmp     $-2             ; huh?
        ...             ; rest of code		остальной код

    На первый взгляд это может сконфузить вас, но все это очень просто. Первая
инструкция заносит "левое" значение в AX. Вторая делает переход на значение
операнда команды MOV AX. '02EB' переводится как 'jmp$+2' (помните, что слова 
хранятся задом наперед)
Этот переход перепрыгивает первый JMP и продолжает дальше по коду.
Вероятно, не будет достаточным для победы над хорошим дизассемблером,таким, 
как Sourcer, но продемонстрирует технику. Проблема в том, может ли
Sourcer схватить код сразу после 'JMP $-2'. Трудно точно сказать, как отреаги-
рует Sourcer, это обычно зависит от байт, находящихся после JMPа. 
(С использованием опции "[A]fter JMP/RET/IRET stay in code" SR v5.04 - не
 пройдет, но если сделать MOV AX,03EBh или т.п. - все будет ОК
 прим.переводчика )
 Чтобы сильно надуть Sourcer, необходимо делать более странные вещи.
Взгляните ка на этот пример.

erp:    mov     ax,0FE05h
        jmp     $-2h
        add     ah,03Bh
        ...                     ; rest of code

Этот код более полезен.  Давайте смоделируем трассировку , показвыая HEX-дамп
каждый шаг, чтобы прояснить ситуацию.

 B8 05 FE EB FC 80 C4 3B   mov     ax,0FE05h       ; ax=FE05h
 ^^ ^^ ^^
 B8 05 FE EB FC 80 C4 3B   jmp     $-2             ; jmp into '05 FE'
          ^^ ^^
 B8 05 FE EB FC 80 C4 3B   add     ax,0EBFEh       ; 05 is 'add ax'
    ^^ ^^ ^^
 B8 05 FE EB FC 80 C4 3B   cld                     ; a dummy instruction
             ^^
 B8 05 FE EB FC 80 C4 3B   add     ah,3Bh          ; ax=2503h
                ^^ ^^ ^^

     Инструкция ADD AH,03Bh здесь означает просто занесение 2503h в AX.
Добавив 5 байт (вместо простого использования 'mov ax,2503h'), этот код
очень хорошо сконфузит дизассемблер. Даже если инструкции дизассемблированы
верно, значение AX будет неизвестно до тех пор, пока не будет помещено в AX.
 Вы можете скрывать значение от дизассемблера, используя 'ADD AX' или 'SUB AX'
везде, где это только возможно.
     Если вы хорошо проверите это, вы сможете увидеть, что любое значение мо-	
жет быть занесено в AX. Два этих значения могут быть изменены на все, что вы
ни пожелаете, а именно FE в первой строке и 3B - в последней. Это помогает при
отладке сквозь эту кодобелиберду для определения значений, необходимых для 
того, чтобы сделать в конце-концов AX таким, каким он должен быть.
   Что касается убийства дебаггеров, очень просто спрятать что-либо типа инст-
рукции HLT в другую инструкцию, такую как JMP.	
Взгляните-ка на это:

glurb:  mov     cx,09EBh
        mov     ax,0FE05h ;-\
        jmp     $-2       ;  >--это вам уже известно
        add     ah,03Bh   ;-/
        jmp     $-10
        ...               ;   остальной код

Три строки в середине - уже известный вам предыдущий пример. Важным здесь явля-
ются первая строка и 'JMP $-10'. 
 Здесь происходит прыжок в 'MOV CX,'. '09EB' превратится в 'JMP $+9'. 
 Посадка прийдется прямо в '$-10' - часть первого JMP'a.  
 $-10 как раз и есть 0F4h - команда HLT. Это будет невидимым при трассировке
 TD386. Кроме того, это невозможно удалить.

     Целью данной статьи не является снабжение вас кодом для использования в
своих программах. Цель - дать вам задуматься о новых путях сокрытия кода от 
модификации.  Самое важное - будьте оригинальными. 

	Будет напрасно просто повторять это, потому что любой, кто прочитал 
эту статью, будет знать, что ты пытаешься сделать.

code            ENDS
                END     concealment
