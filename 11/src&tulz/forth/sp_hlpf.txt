
      ▄▄                  █
     ▀▀▀  Virus Magazine  █ Box 176, Kiev 210, Ukraine      IV  1997
     ▀██ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ █ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀ ▀▀▀▀▐▀▀▀  █▀▀▀▀▀▀█
      ▐█ █▀▄ █▀▀ ▄▀▀ ▄▀▀ ▄█▄ ▄▀▀ █▀█    ▌ █ ▄▀█ █ ▄▀▀ █▄▄   █ █  █ █
       █ █ █ █▀  █▀  █    █  █▀  █ █    █ █ █ █ █ █   █     █ █  █ █
       █ ▐ ▐ ▐   ▐▄▄ ▐▄▄  ▐  ▐▄▄ ▐▄▀     ▀█ ▀▄█ ▐ ▐▄▄ ▐▄▄▄  █ █  █ █
       ▐ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄  █▄▄▄▄▄▄█
          (C) Copyright, 1994-97, by STEALTH group WorldWide, unLtd.

;--------------------------------------------------------------------------
Данная статья выцеплена из комплекта шароварной поставки форта SPForth 1.01
Я убрал только часть описывающую спецификации ЭТОЙ системы! LightGeneral.
;--------------------------------------------------------------------------

   Язык FORTH, являясь ровесником Паскаля и Си (он на год младше Паскаля и
на год старше Си: Паскаль - 1970 г. (Н. Вирт), Форт - 1971 г. (Ч. Мур), Си -
1972 г.(Bell Laboratories)), оказался намного менее популярным на территории
стран бывшего СССР. Причины этому я вижу всего две. Во-первых, Форт выпал из
эволюционного ряда языков программирования, в который входят Си и Паскаль и
начало которому положено, очевидно, Фортраном и Бейсиком. По своей философии
язык Форт очень далек от них, и прямого предка Форта назвать сложно. Он бли-
же, чем к другим, к Лиспу (который отечественным прораммистам знаком немного
разве что по Автокаду), но и Лисп из другого ряда. Поэтому программисты были
совершенно не готовы обратиться немедленно в "новую веру" и не сделали этого.
Кроме того, Форт смог показать всю свою мощь только в эпоху персональных ком-
пьютеров и дал в этом большую фору традиционным языкам, успешно развивающим-
ся на старых платформах. Наша неподготовленность - первая причина. Во-вторых,
отсутствие трансляторов и информации. Многие уважаемые мною программисты (и
среди них те, кого я считаю своими учителями) так прямо мне и говорят: если
бы Форт был действительно хорошим языком, то, очевидно, существовал бы транс-
лятор Turbo Forth или Borland Forth... , и если он не пользуется поддержкой
крупных фирм, то и говорить о нем нечего. Трансляторы фирмы Borland пользу-
ются совершенно заслуженным нашим уважением (и у меня на винчестере, как и у
 вас, есть и TP 6.0, и C++, и Turbo Prolog), но неужели я теперь должен счи-
тать эту фирму виновной в неуспехе Форта ?! По моим данным, популярный (на
Западе) GraForth имеет все же некоторое отношение к фирме Borland Inc. (во
всяком случае существует книга со следующим названием: Lutus P. GraFORTH.
User Manual. Borland Inc.). А поскольку GraForth'а у вас нет, Turbo Forth
тоже не предвидится - возьмите наш скромный SP-FORTH и хотя бы немного поэкс-
периментируйте с ним, преодолевая желание поскорее стереть его, поскольку
"Стройпрогресс" совсем не Borland, а я вовсе не Филипп Кан. Я знаю, что вы
наверняка держали в руках книгу С.Н.Баранова и Н.Р.Ноздрунова "Язык Форт и
его реализации" (и может быть даже прочли ее до страницы 42) и что она не
произвела на вас никакого впечатления. Но позвольте мне все же порекомендо-
вать вам прочесть ее более внимательно и, возможно, вы перестанете считать
Форт неким подобием "развитого макроассемблера". В любом случае, хотя бы ра-
ди любопытства, поближе познакомьтесь с языком, спектр применения которого
очень широк: в свое время программы на Форте управляли подводными лодками,
искавшими "Титаник", телескопами и т.д.; экспертная система, написанная на
Форте, искала неисправности в оборудовании фирмы General Electric; GraForth
управляет трехмерной графикой на ПК IBM PC/XT/AT и он один из очень немногих
языков, удостоившихся чести быть воплощенными "в металле" - на Западе (и, по
непроверенным данным, даже в Эстонии) созданы Форт-процессоры, воспринимаю-
щие Форт, как родной машинный язык. Существуют и многозадачные версии Форта
(в т.ч. для IBM PC - PolyForth фирмы Forth Inc., который также воплощается
"в металле"), чего о Турбо-Паскале не скажешь.
   Как бы я не нахваливал вам Форт, вы не станете программировать на нем до
тех пор, пока своими глазами не убедитесь, что Форт дает в ваши руки хотя
бы тот удобный инструметарий, к которому все привыкли, работая с Турбо-Паска-
лем или Си, и будете совершенно правы. Как минимум должны присутствовать сле-
дующие компоненты: 1) среда программирования (включающая удобный редактор
текстов программ, удобные средства отладки, встроенные средства помощи, фай-
ловую систему); 2) собственно транслятор Форта, который должен иметь средст-
ва для создания быстрого, компактного, удобного в использовании независимо-
го программного продукта; 3) большой набор модулей (библиотек), расширяющих
средства Форта для работы над конкретными прикладными задачами (графика и
т.п.); 4) должен давать средства для работы с использованием новых техноло-
гий программирования, "модных" и действительно удобных, таких как обьектно-
ориентированное программирование (лично я ни за что не обратился бы сейчас
к Форту, если бы не был твердо убежден в том, что мне удастся применять в
работе с ним те же приемы, к которым я уже привык, программируя на Turbo Vi-
sion). Осмелюсь заявить, что уже этот "карликовый" (меньше 6К в базовом ва-
рианте) СП-Форт обладает значительной частью перечисленных возможностей, а
большую часть оставшихся вы можете получить в ТОО "Стройпрогресс-Н", лично у
меня или написать сами, с учетом своих потребностей и вкусов (и сделаете это
быстрее и качественнее, чем на традиционных языках). Все дело в совершенно
ином взгляде на программирование. Если вы не готовы изменить свои привычки
в программировании, или если вас до сих пор полностью удовлетворяли возмож-
ности C++ или Паскаля, и вы не ощущали раздражения при столкновениях с их
ограничениями, если вы любите Турбо Паскаль за то, что он позволяет вам
программировать расслабившись, оставляя все свои ошибки на совести его транс-
лятора, если вы не считаете программирование искусством, и на большее уже не
способны, то Форт не для вас и вы отлично проживете друг без друга.

                           Недостатки Форта

   Самым часто упоминаемым недостатком Форта является использование в нем
стека в явном виде для передачи параметров и следующая отсюда "обратная
польская запись" при программировании вычислений (с этой обратной польской
записью знакомы сейчас практически все, т.к. она используется - и очень
удобно - в калькуляторах МК-61 и МК-52, и аналогичных). Это приводит к
плохой читаемости программ, т.к. манипуляции со стеком трудно проследить.
Это, без сомнения, является для многих программистов очень сильным "отпуги-
вающим средством", им и без стека проблем хватает. Однако данный недостаток
не является таким уж страшным, и при программировании на Форте стек кажется
вполне удобной структурой данных. С другой стороны стек дает и преимущества,
особенно при программировании рекурсивных алгоритмов. Кроме того, стек дан-
ных используется при передаче параметров процедурам практически во всех по-
пулярных трансляторах (в т.ч. в Турбо Паскале), только делается это неявно,
и видно только при дизассемблировании готовой программы (пара команд push
bp, mov bp,sp для доступа к параметрам в стеке стоит в начале практически
любой процедуры Паскаля, а в конце процедуры эти параметры убираются коман-
дой ret <n>). В Форте эта передача сделана явно, что дает неограниченные
возможности оптимизации (человек в вопросах оптимизации пока еще намного
более искусен, чем самые "умные" трансляторы) - разве это плохо ? Если все
же вы не можете примириться со стеком и с постфиксной (обратной польской)
записью, то Форт предоставляет вам все возможности для изменения этой си-
туации, - о том, как использовать локальные переменные и инфиксную форму
записи формул, подробно расказано в [1].
   Другой очевидный недостаток, точнее ограничение, Форта - это работа в
адресном пространстве обьемом всего 64К, что явно не согласуется с боль-
шими обьемами памяти современных ПК. СП-Форт не преодолевает это ограни-
чение, хотя дает средства для его преодоления. Как каждый недостаток,
данный имеет и другую - привлекательную - сторону: повышение компактности
и быстродействия программы. Традиционные для Паскаля "длинные вызовы"
(команды call far, занимающие 5 байт) представляются в Форте всего двумя
байтами в шитом коде. В данный момент не существует 32-разрядной версии
СП-Форта (для работы с 4-байтными адресами), но если вам все же удастся
подойти к пределу памяти в 64К на Форте, то лично для вас я напишу такую
версию. Мне кажется маловероятным исчерпание лимита 64К по следующим при-
чинам: 1) Форт порождает весьма компактный шитый код, и при хорошем стиле
программирования маленькая программа в 60К будет обладать очень большими
возможностями; 2) такую большую (по меркам Форта) программу может написать
только или очень хороший программист (который в состоянии удержать всю эту
программу в голове), или очень плохой программист (который забыл о наличии
винчестера и держит в адресном пространстве Форта редко используемую инфор-
мацию, в результате, конечно, обьем программы растет лавинообразно). Первых
очень мало, и они в состоянии сами решить все проблемы, вторых очень много,
но им не рекомедуется программировать на Форте. Быстродействие программы
практически не снизится, если редко используемые данные или части программы
подгружать только по мере необходимости, СП-Форт дает много средств для
быстрой работы с дисками. Кроме того, в памяти в разных сегментах могут ра-
ботать одновременно несколько программ, написанных на Форте, взаимодейству-
ющих с помощью прерываний или других средств межсегментного обмена, предос-
тавляемых СП-Фортом. Все они будут содержать базовый словарь Форта обьемом
около 6К, одинаковый у всех, что все же нельзя считать слишком расточитель-
ным, ведь в итоге мы можем получить реальную многозадачность. 3) большую
программу может написать группа программистов, работающая над совместным
проектом - в этом случае лучше каждому программисту писать свой модуль в
виде автономной Форт-программы (выполнимого файла типа COM), а затем обь-
единять их как предложено выше.
   Третье, последнее и еще менее существенное, ограничение Форта, которое
часто слишком трагедизируют - это полное отсутствие стандартных средств
для работы с вещественной арифметикой (в формате с плавающей точкой). Это
непривычно для "простого смертного" и ставит его в тупик. Но часто ли встре-
чаются задачи, в которых без вещественной арифметики нельзя обойтись ? Са-
мая распространенная задача, для решения которой традиционно применяется
формат с плавающей точкой - бухгалтерский учет. Но она совсем не сложно, а
главное намного компактнее и быстрее (т.к. действия с целыми числами про-
изводятся компьютером намного быстрее, чем с вещественными, даже при нали-
чии сопроцессора) решается средствами Форта, если считать все в копейках,
а точку в нужном месте ставить лишь при выводе результатов на экран. Как
ни странно, и точность получается более высокой. В Форте набор команд для
работы с целочисленной арифметикой несравненно более широк, чем в традици-
онных языках программирования. Как решать на Форте другие чисто вычислитель-
ные задачи очень хорошо показано в [2]. И тем не менее библиотека для рабо-
ты с вещественной арифметикой считается стандартным расширением Форта, и
такая библиотека будет распространяться нашей фирмой в числе других расши-
рений.
   Все три недостатка Форта (больше нет) скорее демонстрируют недостатки
нашего ленивого ума, не способного к быстрой адаптации. Программируя на
Форте вы вскоре забудете о его мнимых недостатках и, я уверен, получите
истинное удовольствие от использования его неограниченных возможностей.

                  Доступная литература и версии Форта

   В читаемом вами тексте нет описания Форта и файл SP-HELPF.TXT дает лишь
очень краткую информацию об СП-Форте. Поскольку учебник и подробная доку-
ментация программиста в данный бесплатно распространяемый пакет не входят,
я рекомендую вам прежде всего обратиться к "первоисточникам", перечисленным
ниже, а затем все же обратиться к нам за документацией.
   Здесь перечислены книги о Форте, вышедшие на территории бывшего СССР в
течении 1988-92 гг. (те, которые мне удалось достать и прочесть, хотя не
все они у меня сейчас под рукой):
   1. Баранов С.Н., Ноздрунов Н.Р. Язык Форт и его реализации. -Л.: Машино-
строение, 1988. 160 с. Это самое первое крупнотиражное описание языка Форт,
вышедшее в нашей стране, и, на мой взгляд, самое лучшее, несмотря на несколь-
ко серьезных ошибок в текстах программ. Отлично описаны тонкости реализации
(которые необходимо знать для успешного программирования на Форте) и дано
хорошее введение в технику программирования. Пожалуй, без этой книги СП-Форт
просто бы не состоялся. Несмотря на все достоинства данной книги, она очень
непопулярна у профессиональных программистов, хотя есть практически у всех:
введение написано не очень "убедительно", и наверняка большинство читателей
просто не прочли ее до конца, или без должного внимания. Описана техника
обьектно-ориентированного программирования на Форте, хотя это не бросается
в глаза, т.к. в Форте традиционно у всех понятий свои, менее громкие, назва-
ния. Единственное доступное хорошее описание "нового" стандарта FORTH-83.
   2. Броуди Л. Начальный курс программирования на языке Форт. -М.: Финансы
и статистика, 1989. Хорошее введение в программирование на Форте, к сожале-
нию ориентированное на старый стандарт FIG-FORTH (есть существенные отличия).
Мне не удалось полностью прочесть эту книгу, т.к. я получил ее на очень ко-
роткий период, а достать ее сейчас невозможно (мне, во всяком случае). Но
я все-таки очень рекомендую вам попытаться достать и прочесть эту книгу.
   3. Семенов Ю.А. Программирование на языке Форт. -М.: Радио и связь, 1991.
Эта книга, как и [1] относится к числу распространенных и намного более по-
пулярна. Однако, и она ориентирована на старые стандарты FORTH-79 и FIG-
FORTH. От книги вообще "веет стариной", да и достоинства Форта, на мой взг-
ляд, раскрыты недостаточно полно. Не смотря на это, данная книга будет очень
вам полезна: в ней содержится много интересных идей, и к тому же там есть
полный исходный текст Форта-ИТЭФ, написанного Ю.А. Семеновым для IBM PC сов-
местимых машин, т.е., введя этот текст в вашу машину и оттранслировав его
с помощью макроассемблера, вы получите работоспособную версию Форта и, воз-
можно, она понравится вам больше СП-Форта. Когда вышла эта книга, СП-Форта
еще не существовало, и я не взялся бы писать СП-Форт, если бы Форт-ИТЭФ мне
понравился. На ввод текста Форта-ИТЭФ я потратил около трех дней, и еще нес-
колько часов потребовалось на то, чтобы исправить огромное количество оши-
бок (которых в этой книге, как во всех изданиях по программированию, предос-
таточно). Практически пришлось существенно его переделать, чтобы заставить
работать. Форт-ИТЭФ соответствует стандарту FIG-FORTH, обьем файла с базо-
вым словарем, насчитывающим около 250 слов, примерно 7.5К (В СП-Форте соот-
ветственно 220 и 5.6К, а если учитывать те слова, которые загружаются автома-
тически при старте СП-Форта, то >250 и 6.7К), в реализации применен косвен-
ный шитый код - т.е. он заведомо медленнее СП-Форта (доказательства, воспри-
нимаемые на слух, см. в блоке 11 СП-Форта). Минимально возможный обьем неза-
висимой программы на Форте-ИТЭФ из за нерационального расположения системных
буферов составляет более 10К, на СП-Форте обьем готовой программы (COM-фай-
ла) может быть менее 6К. Кроме того, полностью отсутствует докуметация по
использованию нестандартных слов и приходится выяснять их функции по исход-
ному тексту. Впрочем, автор указывает, что от этой версии требовалась сов-
местимость с более старыми версиями Форта в ИТЭФ, поэтому упущения вполне
обьяснимы.
   4. К.Таунсенд, Д.Фохт Проектирование и программная реализация экспертных
систем на персональных ЭВМ. -М.: Финансы и статистика, 1990 г. Очень интерес-
ная книга американских авторов (оригинал издан в 1986 г.), посвященная экс-
пертным системам. Язык Форт (стандарт FORTH-83) рассматривается в нем только
как средство разработки экспертных систем и систем распознования образов. Но
есть и введение в основы программирования на Форте. Прекрасный пример приме-
нения Форта для решения задач, трудно реализуемых при использовании традицион-
ных языков. Показаны способы расширения стандартного Форта удобными средства-
ми обработки списков Лиспа и средствами логического вывода Пролога, получен-
ный "гибрид" используется для написания оболочки экспертной системы (как из-
вестно, Лисп, Форт и Пролог являются основными языками программирования задач
искусственного интеллекта). К сожалению, в книге много ошибок, и качество пе-
ревода на редкость низкое. Тем не менее, я очень рекомендую вам постараться
найти и прочесть эту книгу, даже если вас не очень интересуют экспертные сис-
темы и распознование образов. Все примеры, приведенные в книге, в том числе
тексты программ, реализующих экспертную систему, написаны на Форте-83, поэто-
му вы можете испытывать их на СП-Форте, тем более, что СП-Форт позволяет за-
давать имена новых процедур (слов) на русском языке, как это сделано в книге.
В книге также описаны средства обьектно-ориентированного программирования
стандартного Форта (в данном случае вещи названы своими именами).

   Теперь скажу немного о других версиях Форта, с которыми я раньше имел де-
ло. Сразу отмечу, что на IBM PC я не видел "живьем" ни одного транслятора
Форта, кроме СП-Форта и Форта ИТЭФ, читал о Полифорте и Графорте (о них я уже
упоминал) и читал добротную документацию АстроФорта (об этой версии разговор
особый). Форт не требователен к памяти, поэтому он реализован на всех без
исключения ПК, включая домашние. Именно на домашних ПК я впервые и поработал
на Форте: первым был "FORTH-FSTB", который я собственноручно написал для РК-86
два года назад (настолько меня увлекли идеи книги [1], что я не мог не напи-
сать своей версии Форта), он использовал подпрограммный шитый код (который ме-
нее компактен, чем прямой шитый код, но намного более быстродействующий на ПК
подобного класса); вторым опробованным мною транслятором был превосходный и
очень распространенный на компьютерах с восьмиразрядным процессором К580ВМ80А
Форт К580 версии 6.3, написанный очень известными энтузиастами Форта из ЛГУ
(по моим наблюдениям, Санкт-Петербург вообще является настоящим "питомником"
Форта) В.А.Кириллиным, А.А.Клубовичем и Н.Р.Ноздруновым. Эта версия - лучшее,
что можно порекомендовать пользователям аппаратуры на 580-м процессоре.
Третьим испытанным мною Фортом стал FIG-FORTH на популярном домашнем компью-
тере "Спектрум", по всем признакам это хорошая версия, но она страдает полным
отсутствием документации.
   И наконец Астро-Форт для IBM PC: я никогда его не видел (он не получил рас-
пространения, т.к. поставляется, по всей видимости, с защитой от копирования),
но мне удалось найти и прочитать докуметацию, по которой и могу о нем судить.
Это чрезвычайно мощная версия, которую я вам рекомендую как альтернативу СП-
Форту, если вы сможете ее где-нибудь купить. Он очень похож на Форт К580 и по
этому косвенному признаку можно сделать осторожный вывод, что и авторы у него
те же. Удивило меня только то, что в нем реализованы Паскале-подобные средст-
ва для обьектно-ориентированного программирования, хотя нужды в этом не было,
т.к. для этого в Форте есть свои отличные средства, соответствующие идеологии
Форта, а моделировать на Форте Турбо-Паскаль - это довольно странное решение.
В любом случае, вряд ли вы найдете в СНГ более подходящую версию Форта.
   Работая над СП-Фортом я постарался учесть весь полученный опыт разработки
трансляторов Форта, ориентируясь при разработке прежде всего на стандарт
FORTH-83 и его расширения по образу Форта К580. Мое увлечение Фортом К580 не
могло не сказаться на всей структуре СП-Форта (вплоть до заимствования текс-
тов многих Форт-определений) и я надеюсь, что сказалось положительным обра-
зом. Если вы работали когда-либо на Форте К580 или любом другом стандартном
Форте, то у вас не будет никаких проблем при переходе на СП-Форт: вы только
получите новые удобные возможности.


          Преимущества Форта по сравнению с традиционными языками

   Первое и самое главное: Форт очень легко расширяемый язык. Все новые сред-
ства, определяемые программистом, вводятся в словарь Форта и используются на-
равне с остальными (стандартными) его средствами. Форт "не знает", что в нем
относится к стандарту, а что является расширением. Можно написать свои версии
стандартных слов, например, оператора IF или KEY, (перекрыть метод, как ска-
зали бы некоторые программисты) и Форт автоматически начнет использовать в
дальнейшей работе вашу версию вместо "своей" стандартной до тех пор, пока не
будет введена новая версия этого оператора или до тех пор, пока не будет да-
но "разрешение" использовать старую. К этому полиморфизму мы еще вернемся.
Готовая программа на Форте (COM-файл в случае СП-Форта) может, если вы этому
не воспрепятствуете, содержать в себе все средства трансляции и диалогового
программирования на Форте: практически вы даете в руки конечного пользовате-
ля все те же средства, которыми пользовались сами при разработке программы.
Это дает максимальную, недостижимую на других языках, гибкость программы,
легкость настройки под нужды пользователя. Модифицированная программа может
быть сохранена на диске одной командой SAVE-SYSTEM, без потери возможности
дальнейшей модификации. Таким образом отпадает необходимость использования
каких либо файлов конфигурации или файлов ресурсов, как это принято в тради-
ционном программировании. Не нужно обьяснять, как это облегчает сопровождение
программного продукта. В то время, как все программы на Паскале или Си прак-
тически инертны - они не могут повлиять на работу самих себя - максимум, на
что они способны, это породить новый обьект со старыми методами или считать
из файла ресурсов (и с каким трудом !) новый метод (и то лишь по "совету"
программиста и уже написанный программистом) и для каждой из этих возможнос-
тей существуют весьма скудные средства (например, новый обьект порождается
в Турбо Паскале только функцией New, и ничем больше), - в Форте отсутствуют
какие-либо ограничения: программа может писать "сама себя"; считывать с диска
или с клавиатуры (из любого входного потока) и данные, и команды, причем
и данные, и команды из входного потока могут как сразу выполняться, так и
компилироваться для использования сразу же (прямо при загрузке !) или в даль-
нейшем как равноправная часть программы; программа может и удалять часть сво-
его кода и заменять его новым, причем он может поступать откуда угодно в лю-
бом виде - в исходных текстах на Форте или в виде машинного кода. И для реа-
лизации каждой из этих возможностей в Форте (в этом крошечном стандартном Фор-
те обьемом меньше 6К !) существует масса средств.
   Я сказал "...данные...могут выполняться" и не ошибся, в Форте, строго го-
воря, данных как таковых вообще нет (в обычном их понимании): даже константы
и переменные, определяемые в Форте словами CONSTANT и VARIABLE, не пассивны,
а выполняют некоторые действия. Конструкция CREATE ... DOES> (<BUILD...DOES>
в старых версиях), определяющая данные и одновременно действия над ними, ис-
пользуется в Форте "испокон веков" (с момента его рождения в 1971 г.), а сей-
час нам пытаются преподнести это как нечто новое и нарекли умным словом "ин-
капсуляция". Инкапсуляция, полиморфизм (о котором было сказано выше) и насле-
дование (о котором будет сказано ниже) считаются "тремя китами" наимоднейшей
сейчас технологии программирования, называемой "обьектно ориентированным
программированием". Думал ли Чарльз Мур, создавая более 20 лет назад свой
Форт, что его великолепные идеи пролежат "на полке" невостребованными
как минимум 12-15 лет, а потом вдруг "всплывут" совершенно в другом месте и
под новым названием ! Но он может гордиться, что по виртуозности средств про-
граммирования Форт пока так и остался непревзойденным. Самый простой пример:
можете ли вы на Паскале или на С++ изменить семантику константы в период вы-
полнения ? - например, заставить эту константу (которая стоит у вас в какой-
то формуле) выдавать число 6 вместо 5, или читать эту констату с диска (пря-
мо во время вычисления формулы заставить константу читать саму себя с дис-
ка!), или, что совсем кажется невероятным, выпонить какие-либо совсем "посто-
ронние" действия и при этом исправно давая той формуле то, что требуется ей
для вычислений - какое-то число. Вы не сделаете этого на традиционных языках,
а на Форте соответствующая программа займет, пожалуй, всего одну строчку. Де-
ло в том, что полиморфизм (в терминах обьектно ориентированного программиро-
вания) в Форте распространяется в равной степени и на данные, и на процедуры
(т.к. данные в Форте - такие же равноправные процедуры). В полиморфизме раз-
личают обычно "раннее" (на этапе компиляции) и "позднее" (на этапе выполне-
ния) связывание: в Форте, конечно, есть и то, и другое, причем, если в Турбо
Паскале (да и вообще во всех языках, в которых в последние годы ввели средст-
ва для поддержки ООП) тип полиморфизма задается жестко на этапе компиляции и
зависит от наличия слова virtual в описании процедуры, то в Форте эту ситуа-
цию можно изменить в любой момент: КАЖДОЕ слово-процедуру можно перекрыть в
любое время, динамически или статически. Это дает столь широкие возможности,
что осмыслить, или просто поверить в это, "традиционному программисту" сразу
невозможно - надо просто взять Форт и начать на нем программировать, и вы
вскоре будете вспоминать Паскаль и Си как кошмарный сон.
   Наследование, третий кит ООП, прекрасно реализуется в Форте в виде так
называемых "контексных словарей" (это единственный случай, когда одно и то
же понятие называется в Форте более "заковыристо", чем принято в ООП). Може-
те считать словарь обьектом, каждый новый словарь, определенный внутри него
словом VOCABULARY, будет его потомком и будет наследовать его методы (в Фор-
те, как вы помните, нет обычных данных). Это сильно напоминает вам Турбо Пас-
каль, но в отличие от него, обьект может иметь несколько предков (множествен-
ное наследование, как в C++). Более того, для каждого метода, используемого
внутри нового обьекта, вы можете указать обьекта-хозяина, указав его имя (имя
контексного словаря). Обьект-потомок "видит" все методы и данные в ветви каж-
дого из своих предков, вплоть до "корневого" обьекта с именем FORTH (это имя
базового словаря Форта), и может их использовать. В этом случае имя предка
можно не указывать, оно нужно только для избежания двусмысленности - когда,
например, в двух родительских словарях (обьектах) есть методы с одним и тем
же именем. Причем в одном и том же словаре (обьекте) могут быть слова (мето-
ды), перекрывающие сами себя (описание полиморфизма Форта уже было дано).
Все это дает возможность вам избавиться от примитивных шаблонов использова-
ния средств ООП, навязываемых вам Турбо Паскалем и С++ (хотя ради справедли-
вости надо отметить, что и они являются прекрасными инструментами, просто
Форт - это шаг далеко вперед, (кстати, FORTH так и переводится - "вперед")).
Контексные словари - это один из способов реализации наследования в Форте,
но в Форте есть и второй, совершенно другой (принципиально другой !), хотя
и он вызывает ассоциации с уже знакомыми способами: это реализация наследо-
вания с помощью тех же чудодейственных слов CREATE...DOES>. Это позволяет
полноправно наследовать данные и методы, но не в глобальном масштабе на
уровне словарей, а в местном масштабе - на уровне слов (процедур и их дан-
ных): слово (процедура), в котором встретилась конструкция CREATE...DOES>..,
становится способным само генерировать код слова (и это слово тоже со всеми
основаниями можно считать обьектом, точнее экземпляром обьекта, в терминоло-
гии ООП Турбо Паскаля) с заданием в нем полей данных (которые описаны после
CREATE) и методов над ними (методы описаны после DOES>). Причем, в этом слу-
чае каждому экземпляру обьекта может быть присвоено свое имя, в отличие от
не всегда удобных указателей Паскаля и Си (при этом вы можете работать и с
указателями - в Форте нет абсолютно никаких ограничений !). Самый простой
и самый классический пример обьекта в Форте (хотя никто не пользуется в Фор-
те термином "обьект") - это стандартное слово Форта CONSTANT, которое ис-
пользуется для описания констант (экземпляров обьекта CONSTANT), оно реали-
зуется элементарно:  : CONSTANT CREATE , DOES> @ ;   теперь при выполнении
в программе действий 10 CONSTANT TEN определяется константа TEN со значением
10. Все константы, определенные через это слово CONSTANT, будут использовать
единственный общий метод "@", который собственно и будет класть константу на
стек, доставая ее из поля, сформированного словом "," (запятая). Слова DOES>
и CREATE, хоть часто и используются в паре, совершенно взаимнонезависимы и
не менее часто используются по отдельности. Комбинируя описанные средства
создания обьектов вы можете создавать любые структуры, какие только могут
прийти в голову человека, в том числе и такие, для которых еще не придумали
названия любители звучных терминов.
   Здесь описана лишь небольшая часть достоинств Форта, но и это может выз-
вать у вас недоверие или, в лучшем случае, удивленный вопрос: как же случи-
лось, что вся огромная орда программистов прошла мимо этого прекрасного язы-
ка, неужели все они настолько неразборчивы, - ведь практически все профессио-
нальные программисты в СНГ пишут программы на С++, или, "в крайнем случае"
на Турбо Паскале или Ассемблере. Спросите себя, почему вы в 1988 году, взяв
в книжном магазине в руки книгу [1], прочитали ее аннотацию и, пожалев рубль,
положили ее обратно на полку (лично я тогда поступил именно так), т.к. слово
"Форт" мало о чем вам говорило; или вы все же купили ее, но дома только бег-
ло пролистали (так сделало большинство), сказав себе: у меня есть Турбо Пас-
каль, и мне его достаточно. Трудно было не "клюнуть" на шумную рекламу и
действительные достоинства трансляторов фирмы Borland, тем более, что эти
трансляторы сами плыли нам в руки, любой мог получить бесплатно самые све-
жие версии, а Форта практически ни у кого не было. Что заставило фирму Bor-
land International, Inc., распространявшую в 1983 году GraForth П. Лутуса,
впоследствии бросить его - мне это неизвестно, вероятно он не смог ужиться
под одним крылом вместе с традиционным Паскалем, а может быть, GraForth был
недостаточно хорош.
;--------------------------------------------------------------------------