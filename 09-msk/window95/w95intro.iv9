▄▄                   ▄
▀▀▀ STEALTH GROUP WW █ Mail:   BOX 15, 125080 MOSCOW   ████████ █████████ █▀▀█
▀██ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ █ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀ ▀▀▀▀▐▀▀▀   ┌─┐┬ ┬┌─┤┬ ┬ ╥ ┬┐┌ █▄▄█
 ▐█ █▀▄ █▀▀ ▄▀▀ ▄▀▀ ▄█▄ ▄▀▀ █▀█   ▌ █ ▄▀█ █ ▄▀▀ █▄▄    ├┬┘│ │└─┐├─┤   │└┤ ▄  █
  █ █ █ █▀  █▀  █    █  █▀  █ █   █ █ █ █ █ █   █      ┴└─└─┘└─┘┴ ┴   ┴ ┴ ▀▀▀▀
  █ ▐ ▐ ▐   ▐▄▄ ▐▄▄  ▐  ▐▄▄ ▐▄▀    ▀█ ▀▄█ ▐ ▐▄▄ ▐▄▄▄   ████  WINTER ' 96  ████
  ▐ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄   ███████████████████████

°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°° ФОРТОЧКИ '95 - ОКНО В ... ?

 Introducing Windows 95 by Quantum / VLAD
 ────────────────────────────────────────

  Когда VLAD начал работу над Win'95, все, что нам было необходимо сделать,
  это проработать win32s update к win3.1, позволяющей запускать, хотя и не
  всегда успешно, 32-битные  win95/NT приложения в win3.1.

  Трассируя код, мы заметили, что каждый EXE, при загрузке PE header'а,
  указывает в eax на заголовок и переходит на entrypoint (jmp [eax+28h])
  
  Таким образом, мы изменили entrypoint RVA на начало нашего кода, заPUSHили
  eax, выполнили свой код и вернулись по [eax+28h]. Получился работающий
  win32s инфектор, а потом мы обнаружили, что нам нечем заражать.

  Там не было прерываний и мы really felt out of our depth and then to top it 
  all off  
  мы пошли по обычному пути постановки в резидент без заражения win3.1 shell,
  так родился PH33R. 
  
  Примерно в это же время я покинул поле боя в необьяснимом взрыве сумасшед-
  шей паники "боже мой, я собираюсь to fail uni" и это могло стать концом
  проекта win32s/95/NT.

  Но вскоре uni закончилось. На каникулах, задолбанный своими "черепами",
  я сидел и запускал win95, решив, что "мы пойдем другим путем". К моему
  удивлению, jmp [eax+28] был пройден, это был всего лишь byproduct of win32s.
  Вместо этого я рассчитал расстояние между концом exe и entrypoint, вычислил
  начало вирусного кода и отнял 2. Это работало, я получил win95/NT инфектор.
  
  День, который изменил мир
  ─────────────────────────

  В начале была память и мы смотрели, что делает наш компьютер, peek'ая 
  и poke'ая. И это было хорошо. Но это было не все, на горизонте появились
  "порты" и потихоньку мы научились коммуникациям с присоединенными 
  девайсами, занося и читая информацию через порты.

  Когда компьютер перерос "детство", нам понадобилось что-то, чтобы 
  держать контроль над происходящим. Нам понадобился способ непосред-
  ственной коммуникации с "железом"; так родились прерывания.
  Не всем пришлись они по душе, но вскоре мы изучили их, научились жить
  с ними, управлять ими и использовать в своих нуждах.

  Мы, все, за исключением одной группы в Microsoft - людей, которые 
  писали "революционную" GUI, называемую "Окна".

  Эти ребята искали пути к расчленению всех функций, предоставляемых прерыва-
  ниями. Появились Dll's - shared файлы Dynamic Link Librarys.

  На свет появился API - Application Program Interface. Вызывать функции с
  помощью API стало сложнее, а иногда и вовсе невозможно. Но ребята из
  Microsoft не тронули наших прерываний и мы все еще могли держать контроль
  (частично) над системой, используя DPMI.
  
  Но ребята из Microsoft выкинули еще одну штуку. Их последнее concoction
  убрало все прерывания, порты и ... распределение памяти. "Windows 95/NT" -
  действительно не-примитивная мультизадачная система или, другими словами,-
  бычество.

  Это уродство pushes programs around, заключает их в определенное место
  и накрепко закрывает там, и , самое худшее, заставляет их использовать
  новый, до невозможности комплексный метод вызова API.

  Что привело нас к ...

  ночной попойке в Microsoft
  ───────────────────────────

  Если в Microsoft'е упьются, значит действительно упьются. Но, раньше, чем
  Но раньше, чем они начали бегать в одних трусах и вырывать дорожные столбы,
  они выработали новую конструкцию вызовов.

  В духе Windows 3.1 они выступили против использования прерываний.
  С одной стороны, это хорошо - программерам не надо проверять память на
  уже присутствующие там dll (хотя это можно сделать), и они могут указать
  те dll, которые им нужны.
 
  Реализовали это с помощью Import and Export Tables.
  Import table позволяет программеру указать, что и от какой dll ему нужно.
  Export table позволяет создателю dll описать все доступные в нем функции.

  Проблема в том, что однажды написанная import table уже не может быть 
  изменена.

  Нет места для внесения новых элементов и вы не можете ничего убрать.
  Почему ? В основном, из-за определенной jump table, которая может находиться
  в exe ГДЕ УГОДНО. Для вызова API испоьзуется закрепленный адрес. Он указывает
  на косвенный переход, указывающий на элемент в import table, заполненной 
  (при загрузке executable) адресом подобной jmp table в ddl'е, по которому
  производится push значения и переход на function dispatcher, который исполь-
  зует занчения, находящиеся в dll export table. Для добавления entry в 
  import table вы должны передвинуть текущие entries. Это означает изменение
  jump table для указания на relocated entries, что невозможно, так как
  jump table находится в файле НЕЕИЗВЕСТНО где и ее местонахождение не может
  быть обнаружено.

  Новые Горизонты
  ----------------

  Windows 95 - это целиком новая платформа. Это новый challenge и, хотя
  множество вещей направлено против вас - ЭТО возможно. Начинайте исследования.
  Исследования положат конец войне вирусов/антивирусов так или иначе.

-Словарь:---------------------------------------------------------------


header - заголовок
update - дополнение
entry point - точка входа
shell - оболочка
девайс (device) - устройство
железо (hardware) - аппаратное обеспечение компьютера
table - здесь: таблица
exe,executable - исполняемый (файл)
entry - элемент (таблицы)
relocate - перемещать
relocation table - таблица перемещений
--------------------------------------------------------------------------
PE - Portable Executive - исполняемые файлы NT/win95
DLL - Dynamic Link Library - Динамически присоединяемая Библиотека
share - открытые для одновременного совместного использования 
API - Application Program Interface - Интерфейс прикладных программ
interface - взаимодействие
DPMI - DOS Protected Mode Interface - Интерфейс DOS для Защищенного Режима